<!DOCTYPE html>
<!--
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘  ğŸ† SNAKED â€” All Rights Reserved                     â•‘
  â•‘  Copyright (c) 2025 Jo            â•‘
  â•‘                                                       â•‘
  â•‘  This software is proprietary and confidential.       â•‘
  â•‘  Unauthorized copying, modification, distribution,    â•‘
  â•‘  or use of this file, via any medium, is strictly     â•‘
  â•‘  prohibited without express written permission.       â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="author" content="Jo">
<meta name="copyright" content="Â© 2025 Jo. All rights reserved.">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ğŸ† Snaked</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html {
    overflow: hidden;
    width: 100%;
    height: 100%;
  }
  body {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    overscroll-behavior: none;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background: #1a1a2e;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-height: 100vh; min-height: 100dvh;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    color: #e0e0e0;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }
  h1 {
    font-size: 1.8rem; margin-bottom: 6px;
    background: linear-gradient(135deg, #e8a0bf, #d4789c);
    -webkit-background-clip: text; background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .score-bar {
    display: flex; margin-bottom: 8px; font-size: 1rem;
  }
  .score-bar span { color: #ccc; margin: 0 12px; }
  .score-bar strong { color: #f0c040; }
  .game-wrap {
    position: relative; display: inline-block;
    max-width: 95vw;
  }
  canvas {
    display: block;
    border: 3px solid #3a3a5c; border-radius: 8px; background: #16213e;
    box-shadow: 0 0 30px rgba(200,100,150,0.15);
    touch-action: none;
    max-width: 95vw; max-height: 55vh;
    width: auto; height: auto;
  }
  .controls { margin-top: 10px; font-size: 0.85rem; color: #888; }
  .overlay {
    position: fixed; top:0; left:0; right:0; bottom:0;
    background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
    display: flex; flex-direction: column; align-items: center;
    justify-content: flex-start;
    z-index: 50;
    touch-action: manipulation;
    padding: 10px 15px;
    overflow-y: auto; -webkit-overflow-scrolling: touch;
  }
  .overlay-inner {
    display: flex; flex-direction: column; align-items: center;
    width: 100%; max-width: 400px; flex-shrink: 0;
    margin-top: 20px; padding-bottom: 30px;
  }
  .overlay h2 { font-size: 2.2rem; color: #f0c040; margin-bottom: 6px; }
  .overlay p { font-size: 1rem; color: #ccc; margin-bottom: 10px; text-align: center; padding: 0 10px; }
  .overlay .play-btn {
    padding: 14px 44px; font-size: 1.15rem; border: none; border-radius: 25px;
    background: linear-gradient(135deg, #d4789c, #c0507a); color: white;
    cursor: pointer; touch-action: manipulation; -webkit-appearance: none;
    appearance: none; font-weight: 600; letter-spacing: 0.5px;
    margin-top: 10px;
  }
  .overlay .play-btn:active { transform: scale(0.96); opacity: 0.9; }
  .control-choice {
    display: flex; margin-bottom: 12px;
  }
  .control-choice button {
    padding: 10px 20px; font-size: 0.9rem; border: 2px solid #555; border-radius: 15px;
    background: rgba(255,255,255,0.05); color: #ddd; cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    display: flex; flex-direction: column; align-items: center;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    margin: 0 6px;
  }
  .control-choice button .icon { font-size: 1.5rem; margin-bottom: 3px; display: block; }
  .control-choice button:active { opacity: 0.8; }
  .control-choice button.selected { border-color: #f0c040; background: rgba(240,192,64,0.15); color: #f0c040; }
  .mode-choice { display: flex; margin-bottom: 10px; flex-wrap: wrap; justify-content: center; }
  .mode-choice .mode-btn {
    padding: 8px 14px; font-size: 0.8rem; border: 2px solid #555; border-radius: 12px;
    background: rgba(255,255,255,0.05); color: #ddd; cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    display: flex; flex-direction: column; align-items: center;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    margin: 3px 4px;
  }
  .mode-choice .mode-btn .icon { font-size: 1.2rem; margin-bottom: 2px; display: block; }
  .mode-choice .mode-btn.active { border-color: #f0c040; background: rgba(240,192,64,0.15); color: #f0c040; }

  /* Skin choice â€” horizontal scroll */
  .skin-choice {
    display: flex; margin-bottom: 10px; overflow-x: auto; overflow-y: hidden;
    -webkit-overflow-scrolling: touch; scroll-snap-type: x proximity;
    padding: 4px 0; max-width: 100%; gap: 6px;
    scrollbar-width: none;
  }
  .skin-choice::-webkit-scrollbar { display: none; }
  .skin-choice button {
    padding: 6px 10px; font-size: 0.75rem; border: 2px solid #555; border-radius: 12px;
    background: rgba(255,255,255,0.05); color: #ddd; cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    display: flex; flex-direction: column; align-items: center;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    min-width: 72px; flex-shrink: 0; scroll-snap-align: start;
  }
  .skin-choice button .skin-icon { font-size: 1.2rem; margin-bottom: 2px; display: block; }
  .skin-choice button .skin-name { font-size: 0.6rem; opacity: 0.7; display: block; }
  .skin-choice button:active { opacity: 0.8; }
  .skin-choice button.selected { border-color: #f0c040; background: rgba(240,192,64,0.15); color: #f0c040; }
  .skin-choice button.locked { opacity: 0.4; border-style: dashed; }
  .skin-choice button .skin-price { font-size: 0.55rem; color: #f0c040; margin-top: 1px; }

  /* Leaderboard */
  .leaderboard { margin: 8px 0; width: 100%; max-width: 280px; }
  .leaderboard h3 { font-size: 0.9rem; color: #f0c040; margin-bottom: 6px; }
  .lb-row { display: flex; justify-content: space-between; padding: 3px 8px; font-size: 0.8rem; border-radius: 4px; }
  .lb-row:nth-child(odd) { background: rgba(255,255,255,0.04); }
  .lb-row .lb-rank { color: #888; width: 22px; }
  .lb-row .lb-name { flex: 1; color: #ccc; text-align: left; overflow: hidden; text-overflow: ellipsis; }
  .lb-row .lb-score { color: #f0c040; font-weight: bold; min-width: 40px; text-align: right; }
  .lb-row .lb-coins { color: #ffd700; min-width: 35px; text-align: right; font-size: 0.75rem; }
  .lb-row.lb-new { background: rgba(240,192,64,0.15); }

  /* Shop */
  .shop-btn {
    padding: 8px 18px; font-size: 0.9rem; border: 2px solid #f0c040; border-radius: 20px;
    background: rgba(240,192,64,0.1); color: #f0c040; cursor: pointer;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    font-weight: 600; margin-bottom: 6px; transition: background 0.2s;
  }
  .shop-btn:active { background: rgba(240,192,64,0.25); }
  .shop-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.88); z-index: 100;
    display: none; flex-direction: column; align-items: center;
    justify-content: center; padding: 15px;
    touch-action: manipulation;
  }
  .shop-overlay.open { display: flex; }
  .shop-box {
    background: #1a1a2e; border: 2px solid #3a3a5c; border-radius: 16px;
    padding: 20px; max-width: 360px; width: 100%; max-height: 80vh;
    overflow-y: auto; position: relative;
  }
  .shop-box h2 { text-align: center; color: #f0c040; font-size: 1.4rem; margin-bottom: 4px; }
  .shop-coins { text-align: center; color: #ffd700; font-size: 1rem; margin-bottom: 14px; }
  .shop-item {
    display: flex; align-items: center; padding: 10px; margin-bottom: 8px;
    border: 2px solid #333; border-radius: 12px; background: rgba(255,255,255,0.03);
    transition: border-color 0.2s, background 0.2s;
  }
  .shop-item.active { border-color: #4caf50; background: rgba(76,175,80,0.1); }
  .shop-item .si-icon { font-size: 1.6rem; margin-right: 10px; min-width: 36px; text-align: center; }
  .shop-item .si-info { flex: 1; }
  .shop-item .si-name { color: #eee; font-size: 0.9rem; font-weight: 600; }
  .shop-item .si-desc { color: #888; font-size: 0.72rem; margin-top: 2px; }
  .shop-item .si-btn {
    padding: 6px 12px; border: 2px solid #555; border-radius: 10px;
    background: rgba(255,255,255,0.05); color: #f0c040; font-size: 0.8rem;
    cursor: pointer; touch-action: manipulation; -webkit-appearance: none;
    appearance: none; font-weight: 600; white-space: nowrap; transition: all 0.2s;
  }
  .shop-item .si-btn:active { opacity: 0.8; }
  .shop-item .si-btn.bought { border-color: #4caf50; color: #4caf50; }
  .shop-item .si-btn.cant { opacity: 0.4; cursor: default; }
  .shop-close {
    margin-top: 14px; padding: 10px 30px; border: none; border-radius: 20px;
    background: linear-gradient(135deg, #d4789c, #c0507a); color: white;
    font-size: 1rem; cursor: pointer; touch-action: manipulation;
    -webkit-appearance: none; appearance: none; font-weight: 600;
  }
  .shop-close:active { transform: scale(0.96); }
  .active-bonuses {
    display: flex; justify-content: center; flex-wrap: wrap; gap: 4px; margin-bottom: 8px;
  }
  .active-bonuses .ab-tag {
    font-size: 0.7rem; padding: 2px 8px; border-radius: 10px;
    background: rgba(76,175,80,0.2); border: 1px solid #4caf50; color: #8fd694;
  }

  /* Name input */
  .name-input-wrap { margin: 8px 0; display: flex; align-items: center; gap: 8px; }
  .name-input-wrap input {
    background: rgba(255,255,255,0.1); border: 2px solid #555; border-radius: 8px;
    color: #fff; font-size: 0.9rem; padding: 6px 10px; width: 140px; outline: none;
    font-family: inherit; touch-action: manipulation;
  }
  .name-input-wrap input:focus { border-color: #f0c040; }
  .name-input-wrap input::placeholder { color: #666; }

  /* Arrow controls */
  .mobile-controls {
    display: none; margin-top: 12px;
    grid-template-columns: repeat(3, 58px);
    grid-template-rows: repeat(2, 58px);
    justify-content: center;
  }
  .mobile-controls button {
    width: 58px; height: 58px; font-size: 1.4rem; border: none; border-radius: 12px;
    background: #2a2a4a; color: #ddd; cursor: pointer;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    margin: 2px;
  }
  .mobile-controls button:active { background: #3a3a6a; }
  .mobile-controls .up { grid-column: 2; grid-row: 1; }
  .mobile-controls .left { grid-column: 1; grid-row: 2; }
  .mobile-controls .down { grid-column: 2; grid-row: 2; }
  .mobile-controls .right { grid-column: 3; grid-row: 2; }

  /* Joystick */
  #joystickContainer {
    display: none; margin-top: 12px; position: relative;
    width: 150px; height: 150px; touch-action: none;
  }
  #joystickBase {
    width: 150px; height: 150px; border-radius: 50%;
    background: radial-gradient(circle, #2a2a4a 60%, #1e1e3a 100%);
    border: 2px solid #3a3a5c; position: relative;
    touch-action: none;
  }
  #joystickKnob {
    width: 60px; height: 60px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #d4789c, #a04060);
    border: 2px solid rgba(255,255,255,0.15);
    position: absolute; left: 45px; top: 45px;
    box-shadow: 0 0 15px rgba(212,120,156,0.3);
    pointer-events: none;
    will-change: left, top;
  }

  @media (max-width: 600px) {
    h1 { font-size: 1.4rem; }
    .score-bar { font-size: 0.85rem; }
    .score-bar span { margin: 0 8px; }
    .overlay h2 { font-size: 1.8rem; }
    .overlay p { font-size: 0.95rem; }
  }
  .copyright { text-align:center; margin-top:12px; font-size:0.65rem; color:#444; }
</style>
</head>
<body>
<div class="score-bar" id="scoreBar" style="display:none;">
  <span>Score: <strong id="score">0</strong></span>
  <span>Niveau: <strong id="level">1</strong></span>
  <span>ğŸª™ <strong id="coinCount">0</strong></span>
  <span>Record: <strong id="highscore">0</strong></span>
</div>
<div class="game-wrap">
  <canvas id="game" width="600" height="600"></canvas>
  <div class="overlay" id="startScreen">
   <div class="overlay-inner">
    <h2>ğŸ† Snaked</h2>
    <p>Mange les ğŸ‘ pour grandir !</p>
    <div class="score-bar" style="display:flex;margin-bottom:10px;">
      <span>Score: <strong id="scoreStart">0</strong></span>
      <span>Niveau: <strong id="levelStart">1</strong></span>
      <span>ğŸª™ <strong id="coinCountStart">0</strong></span>
      <span>Record: <strong id="highscoreStart">0</strong></span>
    </div>
    <div class="leaderboard" id="lbStart"></div>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:6px;">ContrÃ´les :</p>
    <div class="control-choice" id="controlChoiceStart">
      <button id="choiceArrows" data-mode="arrows">
        <span class="icon">âŒ¨ï¸</span>
        FlÃ¨ches
      </button>
      <button id="choiceJoystick" data-mode="joystick">
        <span class="icon">ğŸ•¹ï¸</span>
        Joystick
      </button>
    </div>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:6px;">Skin :</p>
    <div class="skin-choice" id="skinChoiceStart"></div>
    <div class="active-bonuses" id="activeBonusesStart"></div>
    <div style="display:flex;gap:8px;margin-bottom:4px;">
      <button class="shop-btn" id="shopBtnStart" style="margin-bottom:0;">ğŸª Boutique</button>
      <button class="shop-btn" id="statsBtnStart" style="margin-bottom:0;background:rgba(100,150,255,0.15);border-color:rgba(100,150,255,0.3);">ğŸ“Š Stats</button>
    </div>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:6px;margin-top:6px;">Mode :</p>
    <div class="mode-choice" id="modeChoice">
      <button class="mode-btn active" data-mode="classic"><span class="icon">ğŸ®</span>Classique</button>
      <button class="mode-btn" data-mode="survival"><span class="icon">ğŸ’€</span>Survie</button>
      <button class="mode-btn" data-mode="chrono"><span class="icon">â±ï¸</span>Chrono 60s</button>
    </div>
    <button class="play-btn" id="btnStart">Jouer</button>
   </div>
  </div>
  <div class="overlay" id="gameOverScreen" style="display:none;">
   <div class="overlay-inner">
    <h2>ğŸ’€ Game Over</h2>
    <p>Score: <strong id="finalScore">0</strong> â€” Niveau <strong id="finalLevel">1</strong></p>
    <p style="font-size:0.9rem;color:#ffd700;" id="coinsEarned"></p>
    <p style="font-size:0.9rem;color:#999;" id="obsCount"></p>
    <p style="font-size:0.9rem;color:#ff6040;" id="comboInfo"></p>
    <div style="text-align:center;margin:6px 0;">
      <button class="shop-btn" id="shareBtn" style="background:rgba(100,200,100,0.15);border-color:rgba(100,200,100,0.3);font-size:0.85rem;padding:6px 16px;">ğŸ“± Partager mon score</button>
    </div>
    <div id="namePrompt" style="display:none;">
      <p style="font-size:0.9rem;color:#f0c040;margin-bottom:4px;">ğŸ† Nouveau record ! Ton nom :</p>
      <div class="name-input-wrap">
        <input type="text" id="nameInput" maxlength="12" placeholder="Pseudo..." autocomplete="off">
        <button class="play-btn" style="padding:6px 14px;font-size:0.85rem;margin:0;" id="btnSaveName">OK</button>
      </div>
    </div>
    <div class="leaderboard" id="lbGameOver"></div>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:6px;">ContrÃ´les :</p>
    <div class="control-choice" id="controlChoiceRestart">
      <button id="choiceArrows2" data-mode="arrows">
        <span class="icon">âŒ¨ï¸</span>
        FlÃ¨ches
      </button>
      <button id="choiceJoystick2" data-mode="joystick">
        <span class="icon">ğŸ•¹ï¸</span>
        Joystick
      </button>
    </div>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:6px;">Skin :</p>
    <div class="skin-choice" id="skinChoiceGO"></div>
    <div class="active-bonuses" id="activeBonusesGO"></div>
    <div style="display:flex;gap:8px;margin-bottom:4px;">
      <button class="shop-btn" id="shopBtnGO" style="margin-bottom:0;">ğŸª Boutique</button>
      <button class="shop-btn" id="statsBtnGO" style="margin-bottom:0;background:rgba(100,150,255,0.15);border-color:rgba(100,150,255,0.3);">ğŸ“Š Stats</button>
    </div>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:6px;margin-top:6px;">Mode :</p>
    <div class="mode-choice" id="modeChoiceGO">
      <button class="mode-btn active" data-mode="classic"><span class="icon">ğŸ®</span>Classique</button>
      <button class="mode-btn" data-mode="survival"><span class="icon">ğŸ’€</span>Survie</button>
      <button class="mode-btn" data-mode="chrono"><span class="icon">â±ï¸</span>Chrono 60s</button>
    </div>
    <button class="play-btn" id="btnRestart">Rejouer</button>
   </div>
  </div>
</div>
<!-- SHOP OVERLAY -->
<div class="shop-overlay" id="shopOverlay">
  <div class="shop-box">
    <h2>ğŸª Boutique</h2>
    <div class="shop-coins">ğŸª™ <strong id="shopCoins">0</strong></div>
    <div id="shopItems"></div>
    <div style="text-align:center;">
      <button class="shop-close" id="shopClose">Fermer</button>
    </div>
  </div>
</div>
<!-- STATS OVERLAY -->
<div class="shop-overlay" id="statsOverlay">
  <div class="shop-box" id="statsContent"></div>
</div>
<div class="mobile-controls" id="arrowControls">
  <button class="up" data-dir="0,-1">â–²</button>
  <button class="left" data-dir="-1,0">â—€</button>
  <button class="down" data-dir="0,1">â–¼</button>
  <button class="right" data-dir="1,0">â–¶</button>
</div>
<div id="joystickContainer">
  <div id="joystickBase">
    <div id="joystickKnob"></div>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ† SNAKED â€” Copyright (c) 2025 Jo
   All Rights Reserved â€” Unauthorized use prohibited.
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Anti-copy: disable right-click context menu
document.addEventListener('contextmenu', function(e) { e.preventDefault(); });

// Console warning
console.log('%câš ï¸ SNAKED â€” Â© 2025 Snaked. Tous droits rÃ©servÃ©s.', 'color: #f0c040; font-size: 14px; font-weight: bold; background: #1a1a2e; padding: 10px; border-radius: 5px;');
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INIT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var canvas = document.getElementById('game');
var ctx = canvas.getContext('2d');
var GRID = 24;
var COLS = canvas.width / GRID;
var ROWS = canvas.height / GRID;

var snake, dir, nextDir, food, score, highScore = 0, gameLoop = null, speed;
var smoothSnake = [];
var lastTime = 0, moveTimer = 0;
var obstacles = [];
var bonusFood = null;
var gameRunning = false;

/* â”€â”€ STATISTICS â”€â”€ */
var stats = {
  totalGames: 0, totalPeaches: 0, totalCoinsEarned: 0,
  totalTimePlayed: 0, bestScore: 0, bestCombo: 0,
  totalDeaths: 0, totalBossKills: 0, skinsOwned: 3
};
var gameStartTime = 0;

/* â”€â”€ COMBO SYSTEM â”€â”€ */
var combo = 0, comboTimer = 0, comboDisplay = null;
var COMBO_WINDOW = 3000; // 3s to eat another peach

/* â”€â”€ DEATH EXPLOSION â”€â”€ */
var deathParticles = [];
var deathAnimating = false;
var deathAnimStart = 0;

/* â”€â”€ BOSS SYSTEM â”€â”€ */
var boss = null; // {x, y, vx, vy, hp, spawnTime, size}
var bossWarning = 0;
var nextBossScore = 25;

/* â”€â”€ GAME MODES â”€â”€ */
var gameMode = 'classic'; // 'classic', 'survival', 'chrono'
var chronoTimer = 60000; // 60s for chrono mode
var survivalTimer = 0;
var survivalSpawnRate = 3000; // initial ms between skull spawns
var survivalSpawnCD = 0; // countdown to next skull

/* â”€â”€ BACKGROUND THEMES â”€â”€ */
var THEMES = {
  classic: { name: 'Classique', icon: 'ğŸŒ‘', cost: 0, bg1: '#1a1a2e', bg2: '#16213e', grid: 'rgba(255,255,255,0.03)' },
  nuit: { name: 'Nuit Ã‰toilÃ©e', icon: 'ğŸŒƒ', cost: 30, bg1: '#0a0a20', bg2: '#0d1030', grid: 'rgba(100,100,200,0.04)', stars: true },
  ocean: { name: 'OcÃ©an', icon: 'ğŸŒŠ', cost: 40, bg1: '#0a2a3a', bg2: '#0d3050', grid: 'rgba(50,150,200,0.05)', waves: true },
  espace: { name: 'Espace', icon: 'ğŸš€', cost: 50, bg1: '#050510', bg2: '#080818', grid: 'rgba(80,60,150,0.04)', nebula: true },
  lave: { name: 'Volcanique', icon: 'ğŸŒ‹', cost: 60, bg1: '#2a0a0a', bg2: '#3a1010', grid: 'rgba(200,60,30,0.05)', lava: true }
};
var currentTheme = 'classic';
var ownedThemes = { classic: true };

/* â”€â”€ ACHIEVEMENTS â”€â”€ */
var ACHIEVEMENTS = [
  {id:'first_game', name:'Premier Pas', icon:'ğŸ‘¶', desc:'Joue ta premiÃ¨re partie', check: function(s){return s.totalGames>=1;}},
  {id:'ten_games', name:'HabituÃ©', icon:'ğŸ®', desc:'Joue 10 parties', check: function(s){return s.totalGames>=10;}},
  {id:'score_10', name:'DÃ©butant', icon:'ğŸ‘', desc:'Atteins 10 points', check: function(s){return s.bestScore>=10;}},
  {id:'score_25', name:'ConfirmÃ©', icon:'ğŸ’ª', desc:'Atteins 25 points', check: function(s){return s.bestScore>=25;}},
  {id:'score_50', name:'Expert', icon:'ğŸ…', desc:'Atteins 50 points', check: function(s){return s.bestScore>=50;}},
  {id:'score_100', name:'LÃ©gende', icon:'ğŸ‘‘', desc:'Atteins 100 points', check: function(s){return s.bestScore>=100;}},
  {id:'coins_50', name:'Bling Bling', icon:'ğŸ’°', desc:'Collecte 50 piÃ¨ces au total', check: function(s){return s.totalCoinsEarned>=50;}},
  {id:'coins_200', name:'Riche', icon:'ğŸ¤‘', desc:'Collecte 200 piÃ¨ces au total', check: function(s){return s.totalCoinsEarned>=200;}},
  {id:'combo_3', name:'Combo!', icon:'ğŸ”¥', desc:'Fais un combo de 3', check: function(s){return s.bestCombo>=3;}},
  {id:'combo_5', name:'EnchaÃ®neur', icon:'âš¡', desc:'Fais un combo de 5', check: function(s){return s.bestCombo>=5;}},
  {id:'combo_10', name:'InarrÃªtable', icon:'ğŸ’¥', desc:'Fais un combo de 10', check: function(s){return s.bestCombo>=10;}},
  {id:'peaches_100', name:'Gourmand', icon:'ğŸ‘', desc:'Mange 100 pÃªches au total', check: function(s){return s.totalPeaches>=100;}},
  {id:'peaches_500', name:'Glouton', icon:'ğŸ·', desc:'Mange 500 pÃªches au total', check: function(s){return s.totalPeaches>=500;}},
  {id:'boss_kill', name:'Tueur de Boss', icon:'ğŸ‘¹', desc:'Bats ton premier boss', check: function(s){return s.totalBossKills>=1;}},
  {id:'boss_5', name:'Chasseur', icon:'ğŸ—¡ï¸', desc:'Bats 5 boss', check: function(s){return s.totalBossKills>=5;}},
  {id:'all_skins', name:'Collectionneur', icon:'ğŸ¨', desc:'PossÃ¨de tous les skins', check: function(s){return s.skinsOwned>=13;}},
  {id:'time_30', name:'Marathon', icon:'â°', desc:'Joue 30 min au total', check: function(s){return s.totalTimePlayed>=1800;}}
];
var unlockedAchievements = {};
var achievementPopup = null; // {name, icon, time}

/* â”€â”€ COINS SYSTEM â”€â”€ */
var coin = null; // current coin on field {x, y, spawnTime}
var coinTimer = 0; // ms since last coin spawn attempt
var COIN_INTERVAL = 5000; // try spawn every 5s
var COIN_LIFETIME = 10000; // coin stays 10s
var coinsThisGame = 0;
var totalCoins = 0;

/* â”€â”€ SHOP SYSTEM â”€â”€ */
var SHOP_ITEMS = [
  {id:'shield',  icon:'ğŸ›¡ï¸', name:'Capote',        cost:5,  desc:'ProtÃ¨ge d\'un impact de ğŸ’€ (1 fois par partie)'},
  {id:'viagra',  icon:'ğŸ’Š', name:'Viagra',         cost:8,  desc:'DÃ©marre avec +3 segments'},
  {id:'magnet',  icon:'ğŸ§²', name:'Aimant',         cost:10, desc:'Les ğŸ‘ se rapprochent quand tu passes Ã  ~4 cases'},
  {id:'ghost',   icon:'ğŸ‘»', name:'Mode FantÃ´me',   cost:12, desc:'10s d\'invincibilitÃ© aux ğŸ’€ en dÃ©but de partie'},
  {id:'rain',    icon:'ğŸ’°', name:'Pluie de Coins', cost:15, desc:'Les ğŸª™ apparaissent 2x plus souvent'},
  {id:'double',  icon:'â­', name:'Double Score',   cost:20, desc:'Chaque ğŸ‘ vaut le double'}
];
// Bonuses activated for next game (toggled in shop)
var activeBonuses = {};
// Runtime state during game
var shieldActive = false;
var ghostActive = false;
var ghostTimer = 0;
var magnetActive = false;
var rainActive = false;
var doubleActive = false;
var slimeTrail = []; // For escargot skin
var frostTrail = []; // For glacÃ© skin
var flameParticles = []; // For diable skin

/* â”€â”€ LEADERBOARD â”€â”€ */
var leaderboard = [];
var playerName = '';

/* â”€â”€ PERSISTENCE (localStorage) â”€â”€ */
function loadSave() {
  try {
    var saved = localStorage.getItem('snaked_save');
    if (saved) {
      var data = JSON.parse(saved);
      totalCoins = data.coins || 0;
      leaderboard = data.leaderboard || [];
      playerName = data.playerName || '';
      highScore = data.highScore || 0;
      activeBonuses = data.activeBonuses || {};
      if (data.ownedSkins) {
        ownedSkins = data.ownedSkins;
        ownedSkins.classic = true; ownedSkins.mamba = true; ownedSkins.savage = true;
      }
      if (data.stats) {
        for (var k in data.stats) { if (data.stats.hasOwnProperty(k)) stats[k] = data.stats[k]; }
      }
      if (data.unlockedAchievements) unlockedAchievements = data.unlockedAchievements;
      if (data.ownedThemes) { ownedThemes = data.ownedThemes; ownedThemes.classic = true; }
      if (data.currentTheme && ownedThemes[data.currentTheme]) currentTheme = data.currentTheme;
    }
  } catch(e) {}
}
function saveSave() {
  try {
    localStorage.setItem('snaked_save', JSON.stringify({
      coins: totalCoins,
      leaderboard: leaderboard,
      playerName: playerName,
      highScore: highScore,
      activeBonuses: activeBonuses,
      ownedSkins: ownedSkins,
      stats: stats,
      unlockedAchievements: unlockedAchievements,
      ownedThemes: ownedThemes,
      currentTheme: currentTheme
    }));
  } catch(e) {}
}
loadSave();
document.getElementById('highscore').textContent = highScore;
document.getElementById('coinCount').textContent = totalCoins;
document.getElementById('highscoreStart').textContent = highScore;
document.getElementById('coinCountStart').textContent = totalCoins;

/* â”€â”€ SHOP FUNCTIONS â”€â”€ */
function renderShop() {
  var container = document.getElementById('shopItems');
  document.getElementById('shopCoins').textContent = totalCoins;
  var html = '<div style="color:#aaa;font-size:0.8rem;margin-bottom:8px;text-align:center;">âš¡ Bonus (usage unique)</div>';
  for (var i = 0; i < SHOP_ITEMS.length; i++) {
    var item = SHOP_ITEMS[i];
    var isActive = activeBonuses[item.id];
    var canAfford = totalCoins >= item.cost;
    var cls = isActive ? 'shop-item active' : 'shop-item';
    var btnCls = isActive ? 'si-btn bought' : (canAfford ? 'si-btn' : 'si-btn cant');
    var btnText = isActive ? 'âœ“ ActivÃ©' : (item.cost + ' ğŸª™');
    html += '<div class="' + cls + '" data-shop-id="' + item.id + '">';
    html += '<div class="si-icon">' + item.icon + '</div>';
    html += '<div class="si-info"><div class="si-name">' + item.name + '</div>';
    html += '<div class="si-desc">' + item.desc + '</div></div>';
    html += '<button class="' + btnCls + '" data-shop-buy="' + item.id + '">' + btnText + '</button>';
    html += '</div>';
  }
  // Skins section
  html += '<div style="color:#aaa;font-size:0.8rem;margin:14px 0 8px;text-align:center;">ğŸ¨ Skins (permanents)</div>';
  for (var s = 0; s < SKIN_ORDER.length; s++) {
    var sid = SKIN_ORDER[s];
    var sk = SKINS[sid];
    if (sk.cost === 0) continue; // Skip free skins
    var owned = ownedSkins[sid];
    var canBuy = totalCoins >= sk.cost;
    var sCls = owned ? 'shop-item active' : 'shop-item';
    var sBtnCls = owned ? 'si-btn bought' : (canBuy ? 'si-btn' : 'si-btn cant');
    var sBtnText = owned ? 'âœ“ PossÃ©dÃ©' : (sk.cost + ' ğŸª™');
    html += '<div class="' + sCls + '">';
    html += '<div class="si-icon">' + sk.icon + '</div>';
    html += '<div class="si-info"><div class="si-name">' + sk.name + '</div>';
    html += '<div class="si-desc">' + sk.desc + '</div></div>';
    html += '<button class="' + sBtnCls + '" data-shop-skin="' + sid + '">' + sBtnText + '</button>';
    html += '</div>';
  }
  // Themes section
  html += '<div style="color:#aaa;font-size:0.8rem;margin:14px 0 8px;text-align:center;">ğŸ¨ ThÃ¨mes de fond</div>';
  var themeKeys = Object.keys(THEMES);
  for (var t = 0; t < themeKeys.length; t++) {
    var tid = themeKeys[t];
    var th = THEMES[tid];
    var tOwned = ownedThemes[tid];
    var tActive = currentTheme === tid;
    var tCanBuy = totalCoins >= th.cost;
    var tCls = tActive ? 'shop-item active' : 'shop-item';
    var tBtnCls = tActive ? 'si-btn bought' : (tOwned ? 'si-btn' : (tCanBuy ? 'si-btn' : 'si-btn cant'));
    var tBtnText = tActive ? 'âœ“ Actif' : (tOwned ? 'Activer' : (th.cost === 0 ? 'Activer' : th.cost + ' ğŸª™'));
    html += '<div class="' + tCls + '">';
    html += '<div class="si-icon">' + th.icon + '</div>';
    html += '<div class="si-info"><div class="si-name">' + th.name + '</div>';
    html += '<div class="si-desc" style="width:12px;height:12px;display:inline-block;border-radius:3px;background:' + th.bg1 + ';border:1px solid rgba(255,255,255,0.2);"></div></div>';
    html += '<button class="' + tBtnCls + '" data-shop-theme="' + tid + '">' + tBtnText + '</button>';
    html += '</div>';
  }
  container.innerHTML = html;
}

function purchaseBonus(id) {
  var item = null;
  for (var i = 0; i < SHOP_ITEMS.length; i++) {
    if (SHOP_ITEMS[i].id === id) { item = SHOP_ITEMS[i]; break; }
  }
  if (!item) return;
  // Toggle off if already active
  if (activeBonuses[id]) {
    delete activeBonuses[id];
    saveSave();
    renderShop();
    renderActiveBonuses();
    return;
  }
  // Purchase
  if (totalCoins < item.cost) return;
  totalCoins -= item.cost;
  activeBonuses[id] = true;
  saveSave();
  document.getElementById('coinCount').textContent = totalCoins;
  document.getElementById('coinCountStart').textContent = totalCoins;
  renderShop();
  renderActiveBonuses();
}

function renderActiveBonuses() {
  var ids = ['activeBonusesStart', 'activeBonusesGO'];
  for (var j = 0; j < ids.length; j++) {
    var el = document.getElementById(ids[j]);
    var html = '';
    for (var i = 0; i < SHOP_ITEMS.length; i++) {
      if (activeBonuses[SHOP_ITEMS[i].id]) {
        html += '<span class="ab-tag">' + SHOP_ITEMS[i].icon + ' ' + SHOP_ITEMS[i].name + '</span>';
      }
    }
    el.innerHTML = html;
  }
}

function openShop() {
  renderShop();
  document.getElementById('shopOverlay').classList.add('open');
}
function closeShop() {
  document.getElementById('shopOverlay').classList.remove('open');
}

function purchaseSkin(id) {
  if (ownedSkins[id]) return; // Already owned
  var sk = SKINS[id];
  if (!sk || totalCoins < sk.cost) return;
  totalCoins -= sk.cost;
  ownedSkins[id] = true;
  saveSave();
  document.getElementById('coinCount').textContent = totalCoins;
  document.getElementById('coinCountStart').textContent = totalCoins;
  renderShop();
  renderSkinChoices();
}

function purchaseTheme(id) {
  if (!THEMES[id]) return;
  if (ownedThemes[id]) { currentTheme = id; saveSave(); renderShop(); return; }
  if (totalCoins < THEMES[id].cost) return;
  totalCoins -= THEMES[id].cost;
  ownedThemes[id] = true;
  currentTheme = id;
  saveSave();
  document.getElementById('coinCount').textContent = totalCoins;
  document.getElementById('coinCountStart').textContent = totalCoins;
  renderShop();
}

renderActiveBonuses();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PREVENT SCROLLING / BOUNCING (targeted â€” not global)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
canvas.addEventListener('touchstart', function(e) { e.preventDefault(); }, { passive: false });

// Mute toggle on canvas tap/click (top-right corner)
function handleMuteClick(cx, cy) {
  var rect = canvas.getBoundingClientRect();
  var x = (cx - rect.left) * (canvas.width / rect.width);
  var y = (cy - rect.top) * (canvas.height / rect.height);
  if (x > canvas.width - 45 && y < 35 && gameRunning) {
    soundMuted = !soundMuted;
    localStorage.setItem('snaked_muted', soundMuted);
  }
}
canvas.addEventListener('click', function(e) { handleMuteClick(e.clientX, e.clientY); });
canvas.addEventListener('touchend', function(e) {
  if (e.changedTouches && e.changedTouches.length > 0) {
    var t = e.changedTouches[0];
    handleMuteClick(t.clientX, t.clientY);
  }
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EMOJI PRE-RENDERS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function preRenderEmoji(emoji, size) {
  size = size || 40;
  var c = document.createElement('canvas');
  c.width = size; c.height = size;
  var cx = c.getContext('2d');
  cx.font = (size - 6) + 'px serif';
  cx.textAlign = 'center';
  cx.textBaseline = 'middle';
  cx.fillText(emoji, size/2, size/2 + 2);
  return c;
}
var peachCanvas = preRenderEmoji('ğŸ‘');
var goldenPeachCanvas = preRenderEmoji('ğŸ‘');
var skullCanvas = preRenderEmoji('ğŸ’€');
var coinCanvas = preRenderEmoji('ğŸª™');

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOUND â€” iOS/Android/Desktop compatible
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var audioCtx = null;
var audioUnlocked = false;
var sounds = {};
var soundMuted = localStorage.getItem('snaked_muted') === 'true';

function initAudioContext() {
  if (audioCtx) return;
  try {
    var AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
  } catch(e) {}
}

function unlockAudio() {
  if (audioUnlocked) return;
  initAudioContext();
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(function(){});
  }
  var allSounds = [sounds.eat, sounds.death, sounds.bonus, sounds.coin];
  for (var i = 0; i < allSounds.length; i++) {
    if (allSounds[i]) {
      allSounds[i].volume = 0.01;
      var p = allSounds[i].play();
      if (p && p.then) {
        (function(s) {
          p.then(function() { s.pause(); s.currentTime = 0; s.volume = s._vol || 0.7; }).catch(function(){});
        })(allSounds[i]);
      }
    }
  }
  audioUnlocked = true;
}

function loadSound(url, vol) {
  var audio = new Audio();
  audio.preload = 'auto';
  audio._vol = vol;
  audio.volume = vol;
  audio.src = url;
  audio.load();
  return audio;
}

function playSound(s) {
  if (!s || soundMuted) return;
  try {
    s.currentTime = 0;
    s.volume = s._vol || 0.7;
    var p = s.play();
    if (p && p.catch) p.catch(function(){});
  } catch(e) {}
}

sounds.eat = loadSound('https://cdn.freesound.org/previews/251/251706_1730960-lq.mp3', 0.7);
sounds.death = loadSound('https://cdn.freesound.org/previews/751/751340_71257-lq.mp3', 0.8);
sounds.bonus = loadSound('https://cdn.freesound.org/previews/403/403828_7821460-lq.mp3', 0.85);
sounds.coin = loadSound('https://cdn.freesound.org/previews/341/341695_5858296-lq.mp3', 0.9);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EJACULATION PARTICLE SYSTEM
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var particles = [];

function spawnEjaculation() {
  var h = smoothSnake[0];
  var dx = dir.x, dy = dir.y;
  var i, spread, spd, sp;

  for (i = 0; i < 28; i++) {
    spread = (Math.random() - 0.5) * 1.6;
    spd = 3 + Math.random() * 6;
    particles.push({
      x: h.x + dx * GRID * 0.5, y: h.y + dy * GRID * 0.5,
      vx: dx * spd + (-dy) * spread * spd * 0.35,
      vy: dy * spd + dx * spread * spd * 0.35,
      size: 2.5 + Math.random() * 5,
      life: 1, decay: 0.007 + Math.random() * 0.014,
      gravity: 0.04 + Math.random() * 0.04,
      type: 'drop',
      wobble: Math.random() * 6.28, wobbleSpd: 0.06 + Math.random() * 0.08
    });
  }
  for (i = 0; i < 5; i++) {
    sp = (Math.random() - 0.5) * 0.6;
    spd = 2.5 + Math.random() * 2.5;
    particles.push({
      x: h.x + dx * GRID * 0.4, y: h.y + dy * GRID * 0.4,
      vx: dx * spd + (-dy) * sp * spd * 0.25,
      vy: dy * spd + dx * sp * spd * 0.25,
      size: 2, life: 1, decay: 0.005 + Math.random() * 0.007,
      gravity: 0.05, type: 'string',
      trail: [], wobble: 0, wobbleSpd: 0
    });
  }
}

function updateParticles() {
  for (var i = particles.length - 1; i >= 0; i--) {
    var p = particles[i];
    p.life -= p.decay;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    if (p.type === 'string') { p.trail.push({x:p.x,y:p.y}); if (p.trail.length > 14) p.trail.shift(); }
    p.vx *= 0.984; p.vy *= 0.984;
    p.vy += p.gravity;
    if (p.wobble !== undefined) p.wobble += p.wobbleSpd;
    p.x += p.vx + (p.wobble ? Math.sin(p.wobble) * 0.3 : 0);
    p.y += p.vy;
    p.size *= 0.998;
  }
}

function drawParticles() {
  for (var pi = 0; pi < particles.length; pi++) {
    var p = particles[pi];
    var a = Math.min(1, p.life * 1.5);

    if (p.type === 'string' && p.trail.length > 2) {
      ctx.strokeStyle = 'rgba(248,244,238,' + (a*0.55) + ')';
      ctx.lineWidth = 1.8 * p.life; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.beginPath(); ctx.moveTo(p.trail[0].x, p.trail[0].y);
      for (var t = 1; t < p.trail.length; t++) ctx.lineTo(p.trail[t].x, p.trail[t].y);
      ctx.lineTo(p.x, p.y); ctx.stroke();
      ctx.fillStyle = 'rgba(252,248,242,' + (a*0.8) + ')';
      ctx.beginPath(); ctx.arc(p.x, p.y, 2.5*p.life, 0, Math.PI*2); ctx.fill();
    } else {
      var spd2 = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
      var ang = Math.atan2(p.vy, p.vx);
      ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(ang);
      var stretch = 1 + spd2 * 0.12;

      var gl = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size * 2.5);
      gl.addColorStop(0, 'rgba(255,255,255,' + (a*0.15) + ')');
      gl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gl;
      ctx.beginPath(); ctx.ellipse(0, 0, p.size*2.5*stretch, p.size*2.5, 0, 0, Math.PI*2); ctx.fill();

      var gr = ctx.createRadialGradient(-p.size*0.15, -p.size*0.15, 0, 0, 0, p.size);
      gr.addColorStop(0, 'rgba(255,252,248,' + (a*0.95) + ')');
      gr.addColorStop(0.4, 'rgba(245,240,232,' + (a*0.8) + ')');
      gr.addColorStop(0.75, 'rgba(232,226,218,' + (a*0.45) + ')');
      gr.addColorStop(1, 'rgba(220,216,208,0)');
      ctx.fillStyle = gr;
      ctx.beginPath(); ctx.ellipse(0, 0, p.size*stretch, p.size, 0, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,' + (a*0.55) + ')';
      ctx.beginPath(); ctx.arc(-p.size*0.22, -p.size*0.22, p.size*0.28, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONTROLS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var controlMode = 'arrows';
var currentSkin = 'classic';

/* â”€â”€ Skin palettes â”€â”€ */
var SKINS = {
  classic: {
    name: 'Le Classique', icon: 'ğŸ¦', cost: 0, desc: 'Doux & rosÃ©',
    grad: ['#d48da5','#c87a94','#dbb5a0','#d4a88c','#cfa085','#c89878'],
    vein: 'rgba(140,85,95,0.18)', veinSec: [0.06, 0.08, 0.10],
    corona: 'rgba(175,95,115,0.45)', meatus: 'rgba(115,40,55,0.75)',
    ballGrad: ['#ecd5be','#dfc4a8','#d0ae90','#bf9a7c','#a88468'],
    ballBridge: ['#c9a080','#d4ae8e','#c9a080'],
    outline: 'rgba(110,65,55,0.12)', hairy: false, special: null
  },
  mamba: {
    name: 'Black Mamba', icon: 'ğŸ', cost: 0, desc: 'Ã‰bÃ¨ne',
    grad: ['#6b3a4a','#5a2838','#4d3a35','#3e2e28','#352520','#2d1f1a'],
    vein: 'rgba(80,30,40,0.25)', veinSec: [0.08, 0.10, 0.12],
    corona: 'rgba(90,40,50,0.55)', meatus: 'rgba(50,15,20,0.85)',
    ballGrad: ['#5c4035','#4d352c','#3e2a22','#30201a','#251815'],
    ballBridge: ['#3e2a22','#4a3028','#3e2a22'],
    outline: 'rgba(30,15,10,0.2)', hairy: false, special: null
  },
  savage: {
    name: 'Le Sauvage', icon: 'ğŸŒ¿', cost: 0, desc: 'Poilu & brut',
    grad: ['#d48da5','#c87a94','#dbb5a0','#d4a88c','#cfa085','#c89878'],
    vein: 'rgba(140,85,95,0.18)', veinSec: [0.06, 0.08, 0.10],
    corona: 'rgba(175,95,115,0.45)', meatus: 'rgba(115,40,55,0.75)',
    ballGrad: ['#ecd5be','#dfc4a8','#d0ae90','#bf9a7c','#a88468'],
    ballBridge: ['#c9a080','#d4ae8e','#c9a080'],
    outline: 'rgba(110,65,55,0.12)', hairy: true, special: null
  },
  cat: {
    name: 'Le Chat', icon: 'ğŸ±', cost: 20, desc: 'Miaou !',
    grad: ['#f0c8a0','#e8b888','#ddb08a','#d4a87c','#cc9c72','#c49068'],
    vein: 'rgba(160,110,70,0.12)', veinSec: [0.04, 0.06, 0.08],
    corona: 'rgba(180,130,90,0.35)', meatus: 'rgba(60,40,30,0.7)',
    ballGrad: ['#f0d8c0','#e4c8a8','#d8b890','#cca878','#c09868'],
    ballBridge: ['#d4b490','#dcc0a0','#d4b490'],
    outline: 'rgba(140,100,60,0.12)', hairy: false, special: 'cat'
  },
  escargot: {
    name: 'Escargot', icon: 'ğŸŒ', cost: 35, desc: 'Bave incluse',
    grad: ['#b8c8a0','#a8b890','#c4b898','#b8a888','#ac9c7c','#a09070'],
    vein: 'rgba(90,110,70,0.15)', veinSec: [0.05, 0.07, 0.09],
    corona: 'rgba(120,140,90,0.4)', meatus: 'rgba(60,80,40,0.7)',
    ballGrad: ['#d0d8b8','#c0c8a8','#b0b898','#a0a888','#909878'],
    ballBridge: ['#b0b898','#bcc4a4','#b0b898'],
    outline: 'rgba(80,90,50,0.15)', hairy: false, special: 'escargot'
  },
  lgbtq: {
    name: 'LGBTQ', icon: 'ğŸ³ï¸â€ğŸŒˆ', cost: 55, desc: 'Pride !',
    grad: ['#e40303','#ff8c00','#ffed00','#008026','#004dff','#750787'],
    vein: 'rgba(255,255,255,0.15)', veinSec: [0.08, 0.10, 0.12],
    corona: 'rgba(255,200,100,0.5)', meatus: 'rgba(100,30,80,0.75)',
    ballGrad: ['#e40303','#ff8c00','#ffed00','#008026','#750787'],
    ballBridge: ['#004dff','#008026','#004dff'],
    outline: 'rgba(100,50,120,0.15)', hairy: false, special: 'lgbtq'
  },
  alien: {
    name: 'Alien', icon: 'ğŸ‘½', cost: 60, desc: 'Bioluminescent',
    grad: ['#40e0a0','#30c888','#28b878','#20a868','#189858','#108848'],
    vein: 'rgba(0,255,180,0.3)', veinSec: [0.12, 0.16, 0.20],
    corona: 'rgba(0,255,150,0.5)', meatus: 'rgba(0,80,50,0.8)',
    ballGrad: ['#50e8a8','#40d898','#30c888','#20b878','#10a868'],
    ballBridge: ['#30c888','#40d898','#30c888'],
    outline: 'rgba(0,200,120,0.2)', hairy: false, special: 'alien'
  },
  knight: {
    name: 'Chevalier', icon: 'ğŸ°', cost: 30, desc: 'En armure !',
    grad: ['#c0c8d0','#a8b0b8','#98a0a8','#889098','#788088','#687078'],
    vein: 'rgba(60,70,80,0.12)', veinSec: [0.04, 0.06, 0.08],
    corona: 'rgba(160,170,180,0.5)', meatus: 'rgba(40,45,50,0.8)',
    ballGrad: ['#b0b8c0','#a0a8b0','#909aa4','#808a94','#707a84'],
    ballBridge: ['#909aa4','#a0a8b0','#909aa4'],
    outline: 'rgba(50,55,65,0.2)', hairy: false, special: 'knight'
  },
  tchernobyl: {
    name: 'Tchernobyl', icon: 'â˜¢ï¸', cost: 50, desc: '3 boules mutantes',
    grad: ['#a8c848','#90b838','#88a840','#78983c','#688838','#587830'],
    vein: 'rgba(100,160,30,0.25)', veinSec: [0.10, 0.14, 0.18],
    corona: 'rgba(140,200,40,0.5)', meatus: 'rgba(50,80,15,0.8)',
    ballGrad: ['#b0d050','#a0c040','#90b030','#80a020','#709018'],
    ballBridge: ['#90b030','#a0c040','#90b030'],
    outline: 'rgba(60,100,20,0.2)', hairy: false, special: 'tchernobyl'
  },
  zombie: {
    name: 'Zombie', icon: 'ğŸ§Ÿ', cost: 40, desc: 'Recousu',
    grad: ['#8a9a70','#7a8a60','#6a7a55','#607050','#586848','#505e40'],
    vein: 'rgba(60,80,40,0.25)', veinSec: [0.10, 0.14, 0.18],
    corona: 'rgba(100,120,70,0.5)', meatus: 'rgba(40,55,25,0.8)',
    ballGrad: ['#90a070','#809060','#708050','#607040','#506030'],
    ballBridge: ['#708050','#809060','#708050'],
    outline: 'rgba(40,55,25,0.2)', hairy: false, special: 'zombie'
  },
  diable: {
    name: 'Diable', icon: 'ğŸ”¥', cost: 70, desc: 'BrÃ»lant !',
    grad: ['#e03030','#c82020','#b82828','#a82020','#981818','#881010'],
    vein: 'rgba(180,40,20,0.2)', veinSec: [0.08, 0.12, 0.16],
    corona: 'rgba(255,80,30,0.55)', meatus: 'rgba(80,10,5,0.85)',
    ballGrad: ['#d04030','#c03020','#b02818','#a02010','#901808'],
    ballBridge: ['#b02818','#c03020','#b02818'],
    outline: 'rgba(120,20,10,0.2)', hairy: false, special: 'diable'
  },
  glace: {
    name: 'GlacÃ©', icon: 'â„ï¸', cost: 80, desc: 'GivrÃ©',
    grad: ['#a0d0f0','#88c0e8','#78b8e0','#68b0d8','#58a0c8','#4890b8'],
    vein: 'rgba(100,160,220,0.15)', veinSec: [0.06, 0.08, 0.10],
    corona: 'rgba(150,210,255,0.5)', meatus: 'rgba(30,70,110,0.75)',
    ballGrad: ['#b0d8f0','#a0c8e8','#90b8e0','#80a8d0','#7098c0'],
    ballBridge: ['#90b8e0','#a0c8e8','#90b8e0'],
    outline: 'rgba(40,80,130,0.15)', hairy: false, special: 'glace'
  },
  banane: {
    name: 'Banane', icon: 'ğŸŒ', cost: 90, desc: 'Ã‰pluchÃ© !',
    grad: ['#f0d840','#e8d030','#e0c828','#d8c020','#d0b818','#c8b010'],
    vein: 'rgba(160,130,20,0.1)', veinSec: [0.04, 0.06, 0.08],
    corona: 'rgba(200,180,40,0.4)', meatus: 'rgba(100,80,10,0.7)',
    ballGrad: ['#f0dc60','#e8d450','#e0cc40','#d8c430','#d0bc20'],
    ballBridge: ['#e0cc40','#e8d450','#e0cc40'],
    outline: 'rgba(140,110,10,0.15)', hairy: false, special: 'banane'
  }
};
var SKIN_ORDER = ['classic','mamba','savage','cat','knight','escargot','zombie','tchernobyl','lgbtq','alien','diable','glace','banane'];
var ownedSkins = {classic:true, mamba:true, savage:true};

function selectSkin(skin) {
  if (!ownedSkins[skin]) return;
  currentSkin = skin;
  renderSkinChoices();
}

function renderSkinChoices() {
  var containers = [document.getElementById('skinChoiceStart'), document.getElementById('skinChoiceGO')];
  for (var c = 0; c < containers.length; c++) {
    var el = containers[c];
    if (!el) continue;
    var html = '';
    for (var i = 0; i < SKIN_ORDER.length; i++) {
      var id = SKIN_ORDER[i];
      var sk = SKINS[id];
      var owned = ownedSkins[id];
      var sel = (id === currentSkin) ? ' selected' : '';
      var locked = owned ? '' : ' locked';
      html += '<button data-skin="' + id + '" class="' + sel + locked + '">';
      html += '<span class="skin-icon">' + sk.icon + '</span>';
      html += '<span class="skin-name">' + escHtml(sk.name) + '</span>';
      if (!owned) html += '<span class="skin-price">ğŸ”’ ' + sk.cost + 'ğŸª™</span>';
      html += '</button>';
    }
    el.innerHTML = html;
  }
}
renderSkinChoices();

function selectControl(mode) {
  controlMode = mode;
  document.getElementById('choiceArrows').classList.toggle('selected', mode === 'arrows');
  document.getElementById('choiceJoystick').classList.toggle('selected', mode === 'joystick');
  var a2 = document.getElementById('choiceArrows2');
  var j2 = document.getElementById('choiceJoystick2');
  if (a2) a2.classList.toggle('selected', mode === 'arrows');
  if (j2) j2.classList.toggle('selected', mode === 'joystick');
}
selectControl('arrows');

function setDir(x, y) {
  if (!gameRunning) return;
  if (x !== -dir.x || y !== -dir.y) nextDir = {x:x, y:y};
}

// Keyboard â€” always works
document.addEventListener('keydown', function(e) {
  var m = {
    ArrowUp:[0,-1], ArrowDown:[0,1], ArrowLeft:[-1,0], ArrowRight:[1,0],
    z:[0,-1], s:[0,1], q:[-1,0], d:[1,0],
    Z:[0,-1], S:[0,1], Q:[-1,0], D:[1,0]
  };
  if (m[e.key]) { e.preventDefault(); setDir(m[e.key][0], m[e.key][1]); }
});

/* â”€â”€ Arrow buttons â€” touchstart primary, pointer/mouse fallback â”€â”€ */
(function initArrowButtons() {
  var btns = document.querySelectorAll('#arrowControls button[data-dir]');
  for (var i = 0; i < btns.length; i++) {
    (function(btn) {
      var parts = btn.getAttribute('data-dir').split(',');
      var x = parseInt(parts[0], 10);
      var y = parseInt(parts[1], 10);
      var handled = false;

      btn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        handled = true;
        setDir(x, y);
        setTimeout(function() { handled = false; }, 300);
      }, { passive: false });

      btn.addEventListener('click', function(e) {
        e.preventDefault();
        if (!handled) setDir(x, y);
      });
    })(btns[i]);
  }
})();

/* â”€â”€ Joystick â€” touch primary, mouse fallback â”€â”€ */
(function initJoystick() {
  var base = document.getElementById('joystickBase');
  var knob = document.getElementById('joystickKnob');
  if (!base || !knob) return;

  var deadZone = 18;
  var active = false;

  function moveKnob(clientX, clientY) {
    var rect = base.getBoundingClientRect();
    var centerX = rect.left + rect.width / 2;
    var centerY = rect.top + rect.height / 2;
    var ox = clientX - centerX;
    var oy = clientY - centerY;
    var dist = Math.sqrt(ox*ox + oy*oy);
    var maxDist = rect.width / 2 - 30; // 30 = knob radius

    var kx = ox, ky = oy;
    if (dist > maxDist) {
      kx = ox / dist * maxDist;
      ky = oy / dist * maxDist;
    }

    // Position knob (left/top relative to base, account for knob size 60px)
    knob.style.left = (rect.width/2 + kx - 30) + 'px';
    knob.style.top = (rect.height/2 + ky - 30) + 'px';

    if (dist > deadZone) {
      var angle = Math.atan2(oy, ox);
      if (angle > -Math.PI/4 && angle <= Math.PI/4) setDir(1, 0);
      else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) setDir(0, 1);
      else if (angle > -3*Math.PI/4 && angle <= -Math.PI/4) setDir(0, -1);
      else setDir(-1, 0);
    }
  }

  function resetKnob() {
    active = false;
    knob.style.left = '45px';
    knob.style.top = '45px';
    knob.style.boxShadow = '0 0 15px rgba(212,120,156,0.3)';
  }

  // Touch events â€” most reliable on iOS Safari
  base.addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    active = true;
    knob.style.boxShadow = '0 0 25px rgba(212,120,156,0.6)';
    moveKnob(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });

  base.addEventListener('touchmove', function(e) {
    if (!active) return;
    e.preventDefault();
    e.stopPropagation();
    moveKnob(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });

  base.addEventListener('touchend', function(e) {
    e.preventDefault();
    if (active) resetKnob();
  }, { passive: false });

  base.addEventListener('touchcancel', function() {
    if (active) resetKnob();
  });

  // Mouse fallback for desktop
  var mouseDown = false;
  base.addEventListener('mousedown', function(e) {
    e.preventDefault();
    mouseDown = true;
    active = true;
    knob.style.boxShadow = '0 0 25px rgba(212,120,156,0.6)';
    moveKnob(e.clientX, e.clientY);
  });
  document.addEventListener('mousemove', function(e) {
    if (!mouseDown) return;
    moveKnob(e.clientX, e.clientY);
  });
  document.addEventListener('mouseup', function() {
    if (mouseDown) { mouseDown = false; resetKnob(); }
  });
})();

function showControls() {
  var arrows = document.getElementById('arrowControls');
  var joystick = document.getElementById('joystickContainer');
  if (controlMode === 'joystick') {
    arrows.style.display = 'none';
    joystick.style.display = 'block';
  } else {
    joystick.style.display = 'none';
    arrows.style.display = 'grid';
  }
}

/* â”€â”€ Overlay buttons â€” simple click (viewport meta eliminates 300ms delay on iOS) â”€â”€ */
(function initButtons() {
  document.getElementById('btnStart').addEventListener('click', function(e) {
    e.preventDefault(); startGame();
  });
  document.getElementById('btnRestart').addEventListener('click', function(e) {
    e.preventDefault(); startGame();
  });

  var choiceBtns = document.querySelectorAll('.control-choice button[data-mode]');
  for (var i = 0; i < choiceBtns.length; i++) {
    (function(btn) {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        selectControl(btn.getAttribute('data-mode'));
      });
    })(choiceBtns[i]);
  }

  // Skin choice buttons (delegated)
  var skinContainers = document.querySelectorAll('.skin-choice');
  for (var j = 0; j < skinContainers.length; j++) {
    skinContainers[j].addEventListener('click', function(e) {
      var btn = e.target.closest('[data-skin]');
      if (btn) {
        e.preventDefault();
        selectSkin(btn.getAttribute('data-skin'));
      }
    });
  }

  // Save name button
  document.getElementById('btnSaveName').addEventListener('click', function(e) {
    e.preventDefault(); savePlayerScore();
  });
  document.getElementById('nameInput').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') { e.preventDefault(); savePlayerScore(); }
  });

  // Shop buttons
  document.getElementById('shopBtnStart').addEventListener('click', function(e) {
    e.preventDefault(); openShop();
  });
  document.getElementById('shopBtnGO').addEventListener('click', function(e) {
    e.preventDefault(); openShop();
  });
  document.getElementById('shopClose').addEventListener('click', function(e) {
    e.preventDefault(); closeShop();
  });
  // Delegate click on shop items
  document.getElementById('shopItems').addEventListener('click', function(e) {
    var btn = e.target.closest('[data-shop-buy]');
    if (btn) {
      e.preventDefault();
      purchaseBonus(btn.getAttribute('data-shop-buy'));
      return;
    }
    var skinBtn = e.target.closest('[data-shop-skin]');
    if (skinBtn) {
      e.preventDefault();
      purchaseSkin(skinBtn.getAttribute('data-shop-skin'));
    }
    var themeBtn = e.target.closest('[data-shop-theme]');
    if (themeBtn) {
      e.preventDefault();
      purchaseTheme(themeBtn.getAttribute('data-shop-theme'));
    }
  });

  // Stats buttons
  document.getElementById('statsBtnStart').addEventListener('click', function(e) {
    e.preventDefault(); renderStatsModal();
  });
  document.getElementById('statsBtnGO').addEventListener('click', function(e) {
    e.preventDefault(); renderStatsModal();
  });

  // Share button
  document.getElementById('shareBtn').addEventListener('click', function(e) {
    e.preventDefault(); shareScore();
  });

  // Mode selection (delegated)
  var modeContainers = document.querySelectorAll('#modeChoice, #modeChoiceGO');
  for (var m = 0; m < modeContainers.length; m++) {
    modeContainers[m].addEventListener('click', function(e) {
      var btn = e.target.closest('.mode-btn');
      if (!btn) return;
      e.preventDefault();
      gameMode = btn.getAttribute('data-mode');
      // Update all mode buttons
      var allModeBtns = document.querySelectorAll('.mode-btn');
      for (var mb = 0; mb < allModeBtns.length; mb++) {
        allModeBtns[mb].classList.toggle('active', allModeBtns[mb].getAttribute('data-mode') === gameMode);
      }
    });
  }
})();

function savePlayerScore() {
  var inp = document.getElementById('nameInput');
  var name = inp.value.trim();
  if (!name) name = 'Joueur';
  playerName = name;
  var rank = insertLeaderboard(name, score, coinsThisGame);
  document.getElementById('namePrompt').style.display = 'none';
  renderLeaderboard('lbGameOver', rank);
  renderLeaderboard('lbStart', -1);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME LOGIC
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function isCellOccupied(x, y) {
  var i;
  for (i = 0; i < snake.length; i++) { if (snake[i].x===x && snake[i].y===y) return true; }
  if (food && food.x===x && food.y===y) return true;
  if (bonusFood && bonusFood.x===x && bonusFood.y===y) return true;
  if (coin && coin.x===x && coin.y===y) return true;
  for (i = 0; i < obstacles.length; i++) { if (obstacles[i].x===x && obstacles[i].y===y) return true; }
  return false;
}

function spawnFood() {
  var p, att = 0;
  do { p = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)}; att++; }
  while (isCellOccupied(p.x, p.y) && att < 200);
  food = p;
  if (!bonusFood && Math.random() < 0.25) {
    var bp, att2 = 0;
    do { bp = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)}; att2++; }
    while (isCellOccupied(bp.x, bp.y) && att2 < 200);
    bonusFood = bp;
  }
}

var screenFlash = 0;
var currentLevel = 1;
var levelUpText = { active: false, time: 0, level: 0 };

function getSkullCount(lvl) {
  // Lvl 1: 0, Lvl 2: 2, Lvl 3: 4, Lvl 4: 6, Lvl 5+: 8 (capped)
  if (lvl <= 1) return 0;
  return Math.min((lvl - 1) * 2, 8);
}

function spawnSafePos() {
  var p, attempts = 0;
  do {
    p = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    attempts++;
  } while (isCellOccupied(p.x, p.y) && attempts < 150);
  if (attempts >= 150) return null;
  var hd = snake[0];
  if (Math.abs(p.x-hd.x) + Math.abs(p.y-hd.y) < 4) return null;
  return p;
}

function spawnLevelObstacles(lvl) {
  var target = getSkullCount(lvl);
  if (target === 0) return;
  var now = performance.now();
  var i, p;

  if (lvl > 5) {
    // After level 5: clear all and regenerate at same count (fresh positions)
    obstacles = [];
  }

  // Spawn skulls up to target
  var toSpawn = target - obstacles.length;
  for (i = 0; i < toSpawn; i++) {
    p = spawnSafePos();
    if (p) obstacles.push({ x:p.x, y:p.y, type:'skull', spawnTime: now, level: lvl });
  }
  screenFlash = 1;
}

function startGame() {
  unlockAudio();
  closeShop();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  document.getElementById('scoreBar').style.display = 'flex';
  showControls();
  var cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
  var startLen = 5;

  // Apply bonuses
  shieldActive = !!activeBonuses.shield;
  ghostActive = !!activeBonuses.ghost;
  ghostTimer = ghostActive ? 10000 : 0; // 10s
  magnetActive = !!activeBonuses.magnet;
  rainActive = !!activeBonuses.rain;
  doubleActive = !!activeBonuses.double;
  if (activeBonuses.viagra) startLen = 8; // +3

  // Consume all activated bonuses (one-time use)
  activeBonuses = {};
  saveSave();
  renderActiveBonuses();

  snake = [];
  for (var i = 0; i < startLen; i++) snake.push({x:cx-i, y:cy});
  smoothSnake = [];
  for (var j = 0; j < snake.length; j++) {
    smoothSnake.push({x:snake[j].x*GRID+GRID/2, y:snake[j].y*GRID+GRID/2});
  }
  dir = {x:1, y:0}; nextDir = {x:1, y:0};
  score = 0; speed = 120; particles = []; obstacles = []; screenFlash = 0; bonusFood = null;
  coin = null; coinTimer = 0; coinsThisGame = 0;
  slimeTrail = []; frostTrail = []; flameParticles = [];
  currentLevel = 1; levelUpText = { active: false, time: 0, level: 0 };
  combo = 0; comboTimer = 0; comboDisplay = null;
  boss = null; bossWarning = 0; nextBossScore = 25;
  deathParticles = []; deathAnimating = false;
  chronoTimer = 60000; survivalTimer = 0; survivalSpawnCD = 3000;
  gameStartTime = performance.now();
  gameRunning = true;
  document.getElementById('score').textContent = '0';
  document.getElementById('level').textContent = '1';
  spawnFood();
  if (gameLoop) cancelAnimationFrame(gameLoop);
  lastTime = performance.now(); moveTimer = 0;
  loop(lastTime);
}

/* â”€â”€ LEADERBOARD FUNCTIONS â”€â”€ */
function renderLeaderboard(containerId, highlightIdx) {
  var el = document.getElementById(containerId);
  if (!leaderboard.length) { el.innerHTML = ''; return; }
  var html = '<h3>ğŸ† Top 5</h3>';
  var medals = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰','4.','5.'];
  for (var i = 0; i < Math.min(leaderboard.length, 5); i++) {
    var entry = leaderboard[i];
    var cls = (i === highlightIdx) ? 'lb-row lb-new' : 'lb-row';
    html += '<div class="' + cls + '">';
    html += '<span class="lb-rank">' + medals[i] + '</span>';
    html += '<span class="lb-name">' + escHtml(entry.name) + '</span>';
    html += '<span class="lb-coins">ğŸª™' + (entry.coins || 0) + '</span>';
    html += '<span class="lb-score">' + entry.score + '</span>';
    html += '</div>';
  }
  el.innerHTML = html;
}
function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}
function getLeaderboardRank(sc) {
  for (var i = 0; i < Math.min(leaderboard.length, 5); i++) {
    if (sc > leaderboard[i].score) return i;
  }
  return leaderboard.length < 5 ? leaderboard.length : -1;
}
function insertLeaderboard(name, sc, coins) {
  var entry = {name: name, score: sc, coins: coins, date: Date.now()};
  var rank = getLeaderboardRank(sc);
  if (rank === -1 && leaderboard.length >= 5) return -1;
  if (rank === -1) rank = leaderboard.length;
  leaderboard.splice(rank, 0, entry);
  if (leaderboard.length > 5) leaderboard.length = 5;
  saveSave();
  return rank;
}

// Init leaderboard on start screen
renderLeaderboard('lbStart', -1);

function gameOver() {
  gameRunning = false;
  playSound(sounds.death);
  // Trigger death explosion animation
  triggerDeathExplosion();
  // The showGameOverScreen() will be called after animation completes
}

function logic() {
  dir = nextDir;
  var head = {x:snake[0].x+dir.x, y:snake[0].y+dir.y};
  // Wrap around edges
  if (head.x < 0) head.x = COLS - 1;
  else if (head.x >= COLS) head.x = 0;
  if (head.y < 0) head.y = ROWS - 1;
  else if (head.y >= ROWS) head.y = 0;
  var i;
  // Self collision (no protection)
  for (i = 0; i < snake.length; i++) {
    if (snake[i].x===head.x && snake[i].y===head.y) return gameOver();
  }
  // Skull collision (shield/ghost can protect)
  for (i = 0; i < obstacles.length; i++) {
    if (obstacles[i].x===head.x && obstacles[i].y===head.y) {
      if (ghostActive) {
        // Ghost: pass through, remove this obstacle
        obstacles.splice(i, 1);
        screenFlash = 0.5;
        break;
      } else if (shieldActive) {
        // Shield: survive once, consume shield
        shieldActive = false;
        obstacles.splice(i, 1);
        screenFlash = 1;
        break;
      } else {
        return gameOver();
      }
    }
  }

  snake.unshift(head);
  smoothSnake.unshift({x:snake[1].x*GRID+GRID/2, y:snake[1].y*GRID+GRID/2});

  // Magnet: teleport food closer if within ~4 cells
  if (magnetActive && food) {
    var fdx = food.x - head.x;
    var fdy = food.y - head.y;
    var fdist = Math.sqrt(fdx*fdx + fdy*fdy);
    if (fdist > 1 && fdist <= 4) {
      // Move food 1 cell closer to head
      var newFx = food.x, newFy = food.y;
      if (Math.abs(fdx) >= Math.abs(fdy)) {
        newFx += (fdx > 0) ? -1 : 1;
      } else {
        newFy += (fdy > 0) ? -1 : 1;
      }
      if (!isCellOccupied(newFx, newFy)) {
        food.x = newFx; food.y = newFy;
      }
    }
  }

  var ate = false;
  var scoreGain = doubleActive ? 2 : 1;
  if (head.x===food.x && head.y===food.y) {
    score += scoreGain; playSound(sounds.eat); spawnEjaculation(); spawnFood(); ate = true;
    stats.totalPeaches++;
  } else if (bonusFood && head.x===bonusFood.x && head.y===bonusFood.y) {
    score += scoreGain * 2; playSound(sounds.bonus); spawnEjaculation(); bonusFood = null; ate = true;
    stats.totalPeaches++;
  }

  // Coin pickup (doesn't grow snake)
  if (coin && head.x===coin.x && head.y===coin.y) {
    playSound(sounds.coin);
    coinsThisGame++;
    totalCoins++;
    stats.totalCoinsEarned++;
    coin = null;
    saveSave();
    document.getElementById('coinCount').textContent = totalCoins;
  }

  // Boss collision (dodge boss = it takes damage)
  if (boss) {
    var bpx = boss.x * GRID + GRID/2, bpy = boss.y * GRID + GRID/2;
    var hpx = head.x * GRID + GRID/2, hpy = head.y * GRID + GRID/2;
    var bdist = Math.sqrt((bpx-hpx)*(bpx-hpx)+(bpy-hpy)*(bpy-hpy));
    if (bdist < GRID * boss.size) {
      if (ghostActive) {
        boss.hp--;
        if (boss.hp <= 0) {
          stats.totalBossKills++;
          boss = null;
          nextBossScore = score + 25;
          screenFlash = 1;
        }
      } else if (shieldActive) {
        shieldActive = false;
        screenFlash = 1;
      } else {
        gameOver(); return;
      }
    }
  }

  if (ate) {
    // Combo system
    combo++;
    comboTimer = COMBO_WINDOW;
    if (combo >= 2) {
      comboDisplay = { count: combo, time: performance.now() };
      // Bonus coins for combos
      if (combo % 3 === 0) { totalCoins++; coinsThisGame++; stats.totalCoinsEarned++; }
    }
    if (combo > stats.bestCombo) stats.bestCombo = combo;

    document.getElementById('score').textContent = score;
    if (speed > 55) speed -= 1.5;
    var newLvl = Math.floor(score / 5) + 1;
    if (newLvl > currentLevel) {
      currentLevel = newLvl;
      document.getElementById('level').textContent = currentLevel;
      if (gameMode !== 'survival') spawnLevelObstacles(currentLevel);
      levelUpText = { active: true, time: performance.now(), level: currentLevel };
    }
    // Boss spawn check
    if (score >= nextBossScore && !boss && gameMode === 'classic') {
      spawnBoss();
    }
  } else {
    snake.pop(); smoothSnake.pop();
  }
}

/* â”€â”€ BOSS SYSTEM â”€â”€ */
function spawnBoss() {
  bossWarning = performance.now();
  setTimeout(function() {
    if (!gameRunning) return;
    var bx, by;
    do { bx = Math.floor(Math.random()*COLS); by = Math.floor(Math.random()*ROWS); }
    while (Math.abs(bx-snake[0].x) < 5 && Math.abs(by-snake[0].y) < 5);
    boss = { x: bx, y: by, hp: 3, spawnTime: performance.now(), size: 2, moveTimer: 0 };
  }, 2000);
}

/* â”€â”€ DEATH EXPLOSION â”€â”€ */
function triggerDeathExplosion() {
  deathParticles = [];
  var hx = smoothSnake[0].x, hy = smoothSnake[0].y;
  var sk = SKINS[currentSkin];
  for (var dp = 0; dp < 40; dp++) {
    var angle = Math.random() * Math.PI * 2;
    var spd = 2 + Math.random() * 5;
    var colors = sk.grad || ['#ff6060','#ff4040','#cc2020'];
    deathParticles.push({
      x: hx, y: hy,
      vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
      size: 3 + Math.random() * 6,
      color: colors[Math.floor(Math.random() * colors.length)],
      life: 1
    });
  }
  // Add bone/skull emoji particles
  for (var bp = 0; bp < 8; bp++) {
    var bAngle = Math.random() * Math.PI * 2;
    var bSpd = 1.5 + Math.random() * 3;
    deathParticles.push({
      x: hx, y: hy,
      vx: Math.cos(bAngle) * bSpd, vy: Math.sin(bAngle) * bSpd,
      size: 12, emoji: bp % 2 === 0 ? 'ğŸ’€' : 'ğŸ¦´',
      life: 1
    });
  }
  deathAnimating = true;
  deathAnimStart = performance.now();
}

function drawDeathExplosion(now, elapsed) {
  var progress = elapsed / 1500;
  // Draw background
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Update and draw particles
  for (var i = 0; i < deathParticles.length; i++) {
    var p = deathParticles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.1; // gravity
    p.vx *= 0.98; p.vy *= 0.98;
    p.life = Math.max(0, 1 - progress);
    if (p.emoji) {
      ctx.globalAlpha = p.life;
      ctx.font = p.size + 'px sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.emoji, p.x, p.y);
      ctx.globalAlpha = 1;
    } else {
      ctx.globalAlpha = p.life * 0.8;
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
  // Flash text
  if (progress < 0.8) {
    ctx.globalAlpha = Math.min(1, progress * 3);
    ctx.font = 'bold 36px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff4444';
    ctx.fillText('ğŸ’€ GAME OVER', canvas.width/2, canvas.height/2);
    ctx.globalAlpha = 1;
  }
}

/* â”€â”€ ACHIEVEMENT SYSTEM â”€â”€ */
function checkAchievements() {
  // Count owned skins
  var sc = 0; for (var k in ownedSkins) { if (ownedSkins[k]) sc++; } stats.skinsOwned = sc;
  for (var i = 0; i < ACHIEVEMENTS.length; i++) {
    var a = ACHIEVEMENTS[i];
    if (!unlockedAchievements[a.id] && a.check(stats)) {
      unlockedAchievements[a.id] = true;
      achievementPopup = { name: a.name, icon: a.icon, time: performance.now() };
      // Reward: 5 coins per achievement
      totalCoins += 5; stats.totalCoinsEarned += 5;
    }
  }
  saveSave();
}

function showGameOverScreen() {
  if (score > highScore) { highScore = score; document.getElementById('highscore').textContent = highScore; }
  if (score > stats.bestScore) stats.bestScore = score;
  stats.totalGames++;
  stats.totalDeaths++;
  stats.totalTimePlayed += (performance.now() - gameStartTime) / 1000;
  saveSave();
  checkAchievements();

  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalLevel').textContent = Math.floor(score/5) + 1;
  document.getElementById('obsCount').textContent = obstacles.length > 0 ? obstacles.length + ' ğŸ’€ sur le terrain' : '';
  document.getElementById('coinsEarned').textContent = coinsThisGame > 0 ? 'ğŸª™ ' + coinsThisGame + ' piÃ¨ce' + (coinsThisGame > 1 ? 's' : '') + ' rÃ©coltÃ©e' + (coinsThisGame > 1 ? 's' : '') : '';
  // Show combo if achieved
  var comboInfo = document.getElementById('comboInfo');
  if (comboInfo) comboInfo.textContent = stats.bestCombo >= 2 ? 'ğŸ”¥ Meilleur combo: ' + stats.bestCombo : '';

  var rank = getLeaderboardRank(score);
  var namePrompt = document.getElementById('namePrompt');
  if (score > 0 && (rank >= 0 || leaderboard.length < 5)) {
    namePrompt.style.display = 'block';
    var inp = document.getElementById('nameInput');
    inp.value = playerName;
    setTimeout(function() { inp.focus(); }, 300);
  } else {
    namePrompt.style.display = 'none';
  }

  renderLeaderboard('lbGameOver', -1);
  document.getElementById('gameOverScreen').style.display = 'flex';
  selectControl(controlMode);
  selectSkin(currentSkin);
}

/* â”€â”€ SHARE SCORE â”€â”€ */
function shareScore() {
  var shareCanvas = document.createElement('canvas');
  shareCanvas.width = 400; shareCanvas.height = 300;
  var sctx = shareCanvas.getContext('2d');
  // Background
  var bgGrd = sctx.createLinearGradient(0, 0, 0, 300);
  bgGrd.addColorStop(0, '#1a1a2e'); bgGrd.addColorStop(1, '#16213e');
  sctx.fillStyle = bgGrd; sctx.fillRect(0, 0, 400, 300);
  // Border
  sctx.strokeStyle = '#f0c040'; sctx.lineWidth = 3;
  sctx.strokeRect(5, 5, 390, 290);
  // Title
  sctx.font = 'bold 32px sans-serif'; sctx.textAlign = 'center'; sctx.textBaseline = 'middle';
  sctx.fillStyle = '#f0c040'; sctx.fillText('ğŸ SNAKED', 200, 40);
  // Score
  sctx.font = 'bold 48px sans-serif'; sctx.fillStyle = '#ffffff';
  sctx.fillText(score + ' pts', 200, 110);
  // Level + mode
  sctx.font = '20px sans-serif'; sctx.fillStyle = '#ccc';
  var modeLabel = gameMode === 'chrono' ? 'â±ï¸ Chrono' : (gameMode === 'survival' ? 'ğŸ’€ Survie' : 'ğŸ® Classique');
  sctx.fillText('Niveau ' + (Math.floor(score/5)+1) + ' â€” ' + modeLabel, 200, 155);
  // Coins
  sctx.fillStyle = '#ffd700'; sctx.font = '18px sans-serif';
  sctx.fillText('ğŸª™ ' + coinsThisGame + ' piÃ¨ces rÃ©coltÃ©es', 200, 190);
  // Combo
  if (stats.bestCombo >= 2) {
    sctx.fillStyle = '#ff6040'; sctx.fillText('ğŸ”¥ Combo max: ' + stats.bestCombo, 200, 215);
  }
  // Watermark
  sctx.font = '14px sans-serif'; sctx.fillStyle = '#666';
  sctx.fillText('snaked-game.com', 200, 275);
  // Try to share or download
  shareCanvas.toBlob(function(blob) {
    if (navigator.share && navigator.canShare) {
      var file = new File([blob], 'snaked-score.png', { type: 'image/png' });
      navigator.share({ title: 'Snaked - Score: ' + score, text: 'J\'ai fait ' + score + ' pts sur Snaked !', files: [file] }).catch(function(){});
    } else {
      var link = document.createElement('a');
      link.download = 'snaked-score.png';
      link.href = URL.createObjectURL(blob);
      link.click();
    }
  }, 'image/png');
}

/* â”€â”€ STATS & ACHIEVEMENTS DISPLAY â”€â”€ */
function renderStatsModal() {
  var html = '<h2>ğŸ“Š Statistiques</h2>';
  html += '<div style="text-align:left;padding:10px;font-size:0.9rem;color:#ccc;line-height:1.8;">';
  html += 'ğŸ® Parties jouÃ©es: <strong style="color:#fff;">' + stats.totalGames + '</strong><br>';
  html += 'ğŸ† Meilleur score: <strong style="color:#f0c040;">' + stats.bestScore + '</strong><br>';
  html += 'ğŸ‘ PÃªches mangÃ©es: <strong style="color:#ff9090;">' + stats.totalPeaches + '</strong><br>';
  html += 'ğŸª™ Coins rÃ©coltÃ©s: <strong style="color:#ffd700;">' + stats.totalCoinsEarned + '</strong><br>';
  html += 'ğŸ”¥ Meilleur combo: <strong style="color:#ff6040;">' + stats.bestCombo + '</strong><br>';
  html += 'ğŸ‘¹ Boss battus: <strong style="color:#e04040;">' + stats.totalBossKills + '</strong><br>';
  html += 'â±ï¸ Temps jouÃ©: <strong style="color:#88ccff;">' + Math.floor(stats.totalTimePlayed/60) + ' min</strong><br>';
  html += '</div>';
  html += '<h3 style="color:#f0c040;margin:8px 0;">ğŸ… SuccÃ¨s (' + Object.keys(unlockedAchievements).length + '/' + ACHIEVEMENTS.length + ')</h3>';
  // Achievement detail popup area
  html += '<div id="achieveDetail" style="min-height:36px;margin:4px 0 8px;padding:6px 12px;border-radius:8px;font-size:0.85rem;color:#ccc;text-align:center;background:rgba(255,255,255,0.05);display:none;"></div>';
  html += '<div style="display:flex;flex-wrap:wrap;gap:6px;justify-content:center;padding:0 8px;">';
  for (var i = 0; i < ACHIEVEMENTS.length; i++) {
    var a = ACHIEVEMENTS[i];
    var unlocked = !!unlockedAchievements[a.id];
    html += '<div data-achieve="' + i + '" style="width:60px;padding:6px 4px;border-radius:8px;text-align:center;cursor:pointer;' +
      (unlocked ? 'background:rgba(240,192,64,0.15);border:1px solid rgba(240,192,64,0.4);' : 'background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);opacity:0.5;') + '">';
    html += '<div style="font-size:1.3rem;">' + a.icon + '</div>';
    html += '<div style="color:' + (unlocked ? '#fff' : '#888') + ';font-size:0.65rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + a.name + '</div>';
    html += '</div>';
  }
  html += '</div>';
  html += '<div style="text-align:center;margin-top:12px;"><button class="shop-close" id="statsClose">Fermer</button></div>';
  document.getElementById('statsContent').innerHTML = html;
  document.getElementById('statsOverlay').classList.add('open');
  document.getElementById('statsClose').addEventListener('click', function() {
    document.getElementById('statsOverlay').classList.remove('open');
  });
  // Achievement click handler
  document.getElementById('statsContent').addEventListener('click', function(e) {
    var el = e.target.closest('[data-achieve]');
    if (!el) return;
    var idx = parseInt(el.getAttribute('data-achieve'));
    var a = ACHIEVEMENTS[idx];
    var unlocked = !!unlockedAchievements[a.id];
    var detail = document.getElementById('achieveDetail');
    detail.style.display = 'block';
    detail.innerHTML = '<strong style="color:' + (unlocked ? '#f0c040' : '#888') + ';">' + a.icon + ' ' + a.name + '</strong><br>' +
      '<span style="font-size:0.8rem;">' + a.desc + '</span><br>' +
      (unlocked ? '<span style="color:#4caf50;font-size:0.75rem;">âœ… DÃ©bloquÃ© !</span>' : '<span style="color:#ff9040;font-size:0.75rem;">ğŸ”’ Pas encore obtenu</span>');
  });
}

function loop(now) {
  // Death animation (plays before resuming normal loop)
  if (deathAnimating) {
    gameLoop = requestAnimationFrame(loop);
    var dElapsed = now - deathAnimStart;
    drawDeathExplosion(now, dElapsed);
    if (dElapsed > 1500) {
      deathAnimating = false;
      cancelAnimationFrame(gameLoop); gameLoop = null;
      showGameOverScreen();
    }
    return;
  }
  gameLoop = requestAnimationFrame(loop);
  var dt = now - lastTime; lastTime = now;
  if (dt > 200) dt = 16; // Cap delta after tab switch to prevent acceleration
  moveTimer += dt;

  // Combo timer decay
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) { combo = 0; comboTimer = 0; }
  }

  // Chrono mode countdown
  if (gameMode === 'chrono') {
    chronoTimer -= dt;
    if (chronoTimer <= 0) { chronoTimer = 0; gameOver(); return; }
  }

  // Survival mode - spawn skulls periodically
  if (gameMode === 'survival') {
    survivalTimer += dt;
    survivalSpawnCD -= dt;
    if (survivalSpawnCD <= 0) {
      // Spawn a skull
      var sp, attempts2 = 0;
      do { sp = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)}; attempts2++; }
      while (isCellOccupied(sp.x, sp.y) && attempts2 < 100);
      if (attempts2 < 100) obstacles.push(sp);
      // Accelerate: rate decreases from 3s to 0.8s over time
      var newRate = Math.max(800, survivalSpawnRate - survivalTimer * 0.015);
      survivalSpawnCD = newRate;
    }
  }

  // Boss movement
  if (boss) {
    boss.moveTimer = (boss.moveTimer || 0) + dt;
    if (boss.moveTimer >= 500) {
      boss.moveTimer = 0;
      // Move toward player
      var bdx = snake[0].x - boss.x, bdy = snake[0].y - boss.y;
      var bm = Math.sqrt(bdx*bdx+bdy*bdy) || 1;
      boss.x += Math.round(bdx/bm);
      boss.y += Math.round(bdy/bm);
      boss.x = Math.max(0, Math.min(COLS-1, boss.x));
      boss.y = Math.max(0, Math.min(ROWS-1, boss.y));
    }
  }

  if (moveTimer >= speed) { moveTimer -= speed; logic(); }

  // Ghost timer countdown
  if (ghostActive && ghostTimer > 0) {
    ghostTimer -= dt;
    if (ghostTimer <= 0) {
      ghostActive = false;
      ghostTimer = 0;
    }
  }

  // Coin spawn/despawn timer (rain = 2x faster)
  var coinInterval = rainActive ? (COIN_INTERVAL / 2) : COIN_INTERVAL;
  coinTimer += dt;
  if (!coin && coinTimer >= coinInterval) {
    coinTimer = 0;
    var coinChance = rainActive ? 0.9 : 0.75;
    if (Math.random() < coinChance) {
      var cp, coinAttempts = 100;
      do { cp = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)}; }
      while (isCellOccupied(cp.x, cp.y) && --coinAttempts > 0);
      coin = {x: cp.x, y: cp.y, spawnTime: now};
    }
  }
  if (coin && (now - coin.spawnTime) > COIN_LIFETIME) {
    coin = null; // despawn
  }
  for (var i = 0; i < snake.length; i++) {
    var t = {x:snake[i].x*GRID+GRID/2, y:snake[i].y*GRID+GRID/2};
    var ddx = t.x - smoothSnake[i].x;
    var ddy = t.y - smoothSnake[i].y;
    // Snap if wrap-around (distance > half canvas)
    if (Math.abs(ddx) > canvas.width * 0.4 || Math.abs(ddy) > canvas.height * 0.4) {
      smoothSnake[i].x = t.x;
      smoothSnake[i].y = t.y;
    } else {
      smoothSnake[i].x += ddx * 0.28;
      smoothSnake[i].y += ddy * 0.28;
    }
  }
  updateParticles();

  // Escargot slime trail
  if (SKINS[currentSkin].special === 'escargot' && smoothSnake.length > 0) {
    var tail = smoothSnake[smoothSnake.length - 1];
    slimeTrail.push({x: tail.x, y: tail.y, t: now});
    while (slimeTrail.length > 300) slimeTrail.shift();
  }

  // GlacÃ© frost trail
  if (SKINS[currentSkin].special === 'glace' && smoothSnake.length > 0) {
    var ftail = smoothSnake[smoothSnake.length - 1];
    frostTrail.push({x: ftail.x, y: ftail.y, t: now});
    while (frostTrail.length > 300) frostTrail.shift();
  }

  // Diable flame particles
  if (SKINS[currentSkin].special === 'diable' && smoothSnake.length > 0) {
    for (var fi = 0; fi < smoothSnake.length; fi += 3) {
      if (Math.random() < 0.3) {
        flameParticles.push({
          x: smoothSnake[fi].x + (Math.random()-0.5)*12,
          y: smoothSnake[fi].y + (Math.random()-0.5)*12,
          vx: (Math.random()-0.5)*1.5,
          vy: -1 - Math.random()*2,
          life: 0.5 + Math.random()*0.5,
          t: now
        });
      }
    }
    // Remove dead flames
    while (flameParticles.length > 0 && (now - flameParticles[0].t)/1000 > flameParticles[0].life) {
      flameParticles.shift();
    }
  }

  draw();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CATMULL-ROM SPLINE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getSpine(pts, sub) {
  sub = sub || 5;
  if (pts.length < 2) return pts.slice();
  var sp = [];
  for (var i = 0; i < pts.length-1; i++) {
    var p0 = pts[Math.max(i-1,0)];
    var p1 = pts[i];
    var p2 = pts[Math.min(i+1,pts.length-1)];
    var p3 = pts[Math.min(i+2,pts.length-1)];
    for (var j = 0; j < sub; j++) {
      var t = j/sub, tt = t*t, ttt = tt*t;
      sp.push({
        x: 0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*tt+(-p0.x+3*p1.x-3*p2.x+p3.x)*ttt),
        y: 0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*tt+(-p0.y+3*p1.y-3*p2.y+p3.y)*ttt)
      });
    }
  }
  sp.push(pts[pts.length-1]);
  return sp;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DRAW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Split smoothSnake into continuous segments (break at wrap points)
function getSegments(pts) {
  var segs = [];
  var cur = [pts[0]];
  var curStart = 0;
  for (var i = 1; i < pts.length; i++) {
    var ddx = pts[i].x - pts[i-1].x;
    var ddy = pts[i].y - pts[i-1].y;
    if (Math.abs(ddx) > canvas.width * 0.35 || Math.abs(ddy) > canvas.height * 0.35) {
      // Wrap detected â€” close current segment, start new one
      if (cur.length >= 2) segs.push({ pts: cur, startIdx: curStart });
      cur = [pts[i]];
      curStart = i;
    } else {
      cur.push(pts[i]);
    }
  }
  if (cur.length >= 2) segs.push({ pts: cur, startIdx: curStart });
  return segs;
}

function drawBodySegment(seg, totalLen, isHead, isTail, now) {
  var spine = getSpine(seg.pts, 5);
  var sLen = spine.length;
  if (sLen < 2) return;

  var globalTotal = Math.max(1, (totalLen - 1) * 5 + 1); // approximate total spine length
  var segGlobalStart = seg.startIdx;
  var segSmoothLen = seg.pts.length;
  var i, w, dx, dy, m, st;

  // Normals
  var normals = [];
  for (i = 0; i < sLen; i++) {
    if (i === 0) { dx = spine[1].x - spine[0].x; dy = spine[1].y - spine[0].y; }
    else if (i === sLen-1) { dx = spine[sLen-1].x - spine[sLen-2].x; dy = spine[sLen-1].y - spine[sLen-2].y; }
    else { dx = spine[i+1].x - spine[i-1].x; dy = spine[i+1].y - spine[i-1].y; }
    m = Math.sqrt(dx*dx + dy*dy) || 1;
    normals.push({x: -dy/m, y: dx/m});
  }

  // Width profile â€” maps local spine index to global snake position
  function getW(idx) {
    // Map local idx to global fraction
    var localFrac = idx / (sLen - 1);
    var globalSmooth = segGlobalStart + localFrac * (segSmoothLen - 1);
    var t2 = globalSmooth / (totalLen - 1);
    var base = GRID * 0.5;
    if (t2 < 0.015) return base * 0.6;
    if (t2 < 0.05) return base * 1.0;
    if (t2 < 0.09) return base * 1.15;
    if (t2 < 0.12) return base * 1.22;
    if (t2 < 0.15) return base * 0.82;
    if (t2 > 0.93) return base * Math.max(0.1, 0.8 - (t2 - 0.93) * 10);
    return base * (0.9 + 0.07 * Math.sin(t2 * 14));
  }

  var leftPts = [], rightPts = [];
  for (i = 0; i < sLen; i++) {
    w = getW(i);
    leftPts.push({x: spine[i].x + normals[i].x * w, y: spine[i].y + normals[i].y * w});
    rightPts.push({x: spine[i].x - normals[i].x * w, y: spine[i].y - normals[i].y * w});
  }

  // Shadow
  ctx.save(); ctx.translate(3, 5);
  ctx.beginPath(); ctx.moveTo(leftPts[0].x, leftPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(leftPts[i].x, leftPts[i].y);
  for (i = sLen-1; i >= 0; i--) ctx.lineTo(rightPts[i].x, rightPts[i].y);
  ctx.closePath(); ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fill(); ctx.restore();

  // Main body (clipped)
  ctx.save();
  ctx.beginPath(); ctx.moveTo(leftPts[0].x, leftPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(leftPts[i].x, leftPts[i].y);
  for (i = sLen-1; i >= 0; i--) ctx.lineTo(rightPts[i].x, rightPts[i].y);
  ctx.closePath(); ctx.clip();

  // Skin gradient
  var sk = SKINS[currentSkin];
  var hP = spine[0], tP2 = spine[sLen-1];
  var bg = ctx.createLinearGradient(hP.x, hP.y, tP2.x, tP2.y);
  if (sk.special === 'lgbtq') {
    // Animated rainbow: shift colors over time
    var rainbowColors = ['#e40303','#ff8c00','#ffed00','#008026','#004dff','#750787'];
    var shift = ((now || 0) * 0.001) % 6;
    for (var rc = 0; rc < 6; rc++) {
      var ci = Math.floor(shift + rc) % 6;
      bg.addColorStop(rc / 5, rainbowColors[ci]);
    }
  } else {
    bg.addColorStop(0, sk.grad[0]); bg.addColorStop(0.10, sk.grad[1]);
    bg.addColorStop(0.17, sk.grad[2]); bg.addColorStop(0.3, sk.grad[3]);
    bg.addColorStop(0.7, sk.grad[4]); bg.addColorStop(1, sk.grad[5]);
  }
  ctx.fillStyle = bg; ctx.fillRect(0, 0, canvas.width, canvas.height);

  // 3D cylinder shading
  for (i = 0; i < sLen-1; i++) {
    w = getW(i);
    var cx2 = spine[i].x, cy2 = spine[i].y, nx2 = normals[i].x, ny2 = normals[i].y;
    var g = ctx.createLinearGradient(cx2+nx2*w, cy2+ny2*w, cx2-nx2*w, cy2-ny2*w);
    g.addColorStop(0, 'rgba(255,230,220,0.35)'); g.addColorStop(0.2, 'rgba(255,255,255,0.12)');
    g.addColorStop(0.45, 'rgba(0,0,0,0)'); g.addColorStop(0.7, 'rgba(0,0,0,0.08)');
    g.addColorStop(1, 'rgba(0,0,0,0.22)');
    ctx.fillStyle = g; ctx.beginPath();
    ctx.moveTo(leftPts[i].x, leftPts[i].y); ctx.lineTo(leftPts[i+1].x, leftPts[i+1].y);
    ctx.lineTo(rightPts[i+1].x, rightPts[i+1].y); ctx.lineTo(rightPts[i].x, rightPts[i].y);
    ctx.closePath(); ctx.fill();
  }

  // Dorsal vein
  st = false;
  ctx.strokeStyle = sk.vein; ctx.lineWidth = 2; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.beginPath();
  for (i = Math.floor(sLen*0.15); i < Math.floor(sLen*0.88); i += 2) {
    var o = 0.28 + Math.sin(i*0.08) * 0.08;
    var vx = spine[i].x + normals[i].x * getW(i) * o + Math.sin(i*0.12) * 2.5;
    var vy = spine[i].y + normals[i].y * getW(i) * o + Math.cos(i*0.1) * 2.5;
    if (!st) { ctx.moveTo(vx, vy); st = true; } else ctx.lineTo(vx, vy);
  }
  ctx.stroke();

  // Secondary veins
  for (var v = 0; v < 3; v++) {
    ctx.strokeStyle = sk.vein.replace(/[\d.]+\)$/, sk.veinSec[v] + ')'); ctx.lineWidth = 0.8;
    ctx.beginPath(); st = false;
    var ov = [-0.35, 0.1, -0.15][v];
    var s0 = Math.floor(sLen*(0.18+v*0.08)), s1 = Math.floor(sLen*(0.65+v*0.1));
    for (i = s0; i < s1; i += 3) {
      var vx2 = spine[i].x + normals[i].x * getW(i) * ov + Math.sin(i*0.2+v*5) * 1.5;
      var vy2 = spine[i].y + normals[i].y * getW(i) * ov + Math.cos(i*0.15+v*5) * 1.5;
      if (!st) { ctx.moveTo(vx2, vy2); st = true; } else ctx.lineTo(vx2, vy2);
    }
    ctx.stroke();
  }

  // Top specular
  ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 3.5;
  ctx.beginPath(); st = false;
  for (i = Math.floor(sLen*0.04); i < Math.floor(sLen*0.92); i += 2) {
    var hx = spine[i].x + normals[i].x * getW(i) * 0.6;
    var hy = spine[i].y + normals[i].y * getW(i) * 0.6;
    if (!st) { ctx.moveTo(hx, hy); st = true; } else ctx.lineTo(hx, hy);
  }
  ctx.stroke();

  // Skin pores
  ctx.fillStyle = 'rgba(180,130,110,0.04)';
  for (i = Math.floor(sLen*0.15); i < Math.floor(sLen*0.9); i += 4) {
    for (var d2 = 0; d2 < 2; d2++) {
      var px = spine[i].x + normals[i].x * getW(i) * (Math.sin(i+d2*11)*0.5) + Math.sin(i*2.3+d2*7) * 2;
      var py = spine[i].y + normals[i].y * getW(i) * (Math.cos(i+d2*7)*0.5) + Math.cos(i*1.8+d2*3) * 2;
      ctx.beginPath(); ctx.arc(px, py, 0.8, 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ KNIGHT ARMOR PLATES â”€â”€
  if (sk.special === 'knight') {
    for (i = Math.floor(sLen*0.18); i < Math.floor(sLen*0.9); i += 8) {
      var aw = getW(i);
      if (aw < 2) continue;
      // Horizontal plate line
      ctx.strokeStyle = 'rgba(200,210,220,0.4)'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(spine[i].x + normals[i].x*aw*0.9, spine[i].y + normals[i].y*aw*0.9);
      ctx.lineTo(spine[i].x - normals[i].x*aw*0.9, spine[i].y - normals[i].y*aw*0.9);
      ctx.stroke();
      // Rivet dots
      for (var rv = -1; rv <= 1; rv += 2) {
        var rvx = spine[i].x + normals[i].x*aw*0.5*rv;
        var rvy = spine[i].y + normals[i].y*aw*0.5*rv;
        ctx.fillStyle = 'rgba(220,225,230,0.5)';
        ctx.beginPath(); ctx.arc(rvx, rvy, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(160,165,175,0.4)';
        ctx.beginPath(); ctx.arc(rvx+0.5, rvy+0.5, 0.8, 0, Math.PI*2); ctx.fill();
      }
    }
    // Metallic sheen highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 2.5;
    ctx.beginPath(); var kst = false;
    for (i = Math.floor(sLen*0.05); i < Math.floor(sLen*0.9); i += 2) {
      var kx = spine[i].x + normals[i].x * getW(i) * 0.4;
      var ky = spine[i].y + normals[i].y * getW(i) * 0.4;
      if (!kst) { ctx.moveTo(kx,ky); kst=true; } else ctx.lineTo(kx,ky);
    }
    ctx.stroke();
  }

  // â”€â”€ ZOMBIE STITCHES â”€â”€
  if (sk.special === 'zombie') {
    ctx.lineCap = 'round';
    // Main suture line along shaft
    ctx.strokeStyle = 'rgba(80,40,30,0.5)'; ctx.lineWidth = 1.5;
    ctx.beginPath(); var zst = false;
    for (i = Math.floor(sLen*0.2); i < Math.floor(sLen*0.85); i += 2) {
      var zo = Math.sin(i*0.15)*0.15;
      var zx = spine[i].x + normals[i].x*getW(i)*zo;
      var zy = spine[i].y + normals[i].y*getW(i)*zo;
      if (!zst) { ctx.moveTo(zx,zy); zst=true; } else ctx.lineTo(zx,zy);
    }
    ctx.stroke();
    // Cross stitches
    ctx.strokeStyle = 'rgba(60,30,20,0.55)'; ctx.lineWidth = 1.2;
    for (i = Math.floor(sLen*0.22); i < Math.floor(sLen*0.83); i += 6) {
      var sw = getW(i) * 0.35;
      var zo2 = Math.sin(i*0.15)*0.15;
      var scx = spine[i].x + normals[i].x*getW(i)*zo2;
      var scy = spine[i].y + normals[i].y*getW(i)*zo2;
      // X stitch
      ctx.beginPath();
      ctx.moveTo(scx + normals[i].x*sw, scy + normals[i].y*sw);
      ctx.lineTo(scx - normals[i].x*sw, scy - normals[i].y*sw);
      ctx.stroke();
    }
    // Dark rot patches
    for (i = Math.floor(sLen*0.2); i < Math.floor(sLen*0.85); i += 12) {
      var rw = getW(i);
      var rSide = (i % 2 === 0) ? 0.3 : -0.25;
      var rrx = spine[i].x + normals[i].x*rw*rSide;
      var rry = spine[i].y + normals[i].y*rw*rSide;
      ctx.fillStyle = 'rgba(50,60,30,0.15)';
      ctx.beginPath(); ctx.arc(rrx, rry, 3 + Math.sin(i)*1.5, 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ HAIR (Le Sauvage only) â”€â”€
  if (sk.hairy) {
    ctx.lineCap = 'round';
    for (var hp = 0; hp < 3; hp++) {
      for (i = Math.floor(sLen*0.15); i < Math.floor(sLen*0.94); i += 1) {
        var hairW = getW(i);
        if (hairW < 2) continue;
        var chance = hp === 0 ? 0.35 : (hp === 1 ? 0.25 : 0.15);
        if (Math.random() > chance) continue;
        var hairSide = (Math.random() > 0.5) ? 1 : -1;
        var hairOff = 0.25 + Math.random() * 0.75;
        var baseX = spine[i].x + normals[i].x * hairW * hairOff * hairSide;
        var baseY = spine[i].y + normals[i].y * hairW * hairOff * hairSide;
        var hairLen = hp === 0 ? (6 + Math.random() * 10) : (hp === 1 ? (4 + Math.random() * 7) : (2 + Math.random() * 4));
        var hairAng = Math.atan2(normals[i].y * hairSide, normals[i].x * hairSide) + (Math.random() - 0.5) * 0.8;
        var tipX = baseX + Math.cos(hairAng) * hairLen;
        var tipY = baseY + Math.sin(hairAng) * hairLen;
        var hairAlpha = hp === 0 ? (0.55 + Math.random() * 0.3) : (hp === 1 ? (0.35 + Math.random() * 0.25) : (0.2 + Math.random() * 0.15));
        ctx.strokeStyle = 'rgba(30,15,5,' + hairAlpha + ')';
        ctx.lineWidth = hp === 0 ? (0.9 + Math.random() * 1.1) : (hp === 1 ? (0.5 + Math.random() * 0.7) : (0.3 + Math.random() * 0.4));
        ctx.beginPath(); ctx.moveTo(baseX, baseY);
        var cpX = (baseX + tipX) / 2 + (Math.random() - 0.5) * 5;
        var cpY = (baseY + tipY) / 2 + (Math.random() - 0.5) * 5;
        ctx.quadraticCurveTo(cpX, cpY, tipX, tipY);
        ctx.stroke();
      }
    }
  }

  ctx.restore();

  // Outline
  ctx.strokeStyle = sk.outline; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(leftPts[0].x, leftPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(leftPts[i].x, leftPts[i].y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(rightPts[0].x, rightPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(rightPts[i].x, rightPts[i].y); ctx.stroke();

  // â”€â”€ HEAD FEATURES (only for head segment) â”€â”€
  if (isHead) {
    if (sk.special === 'cat') {
      // â”€â”€ CAT HEAD â”€â”€
      var cSpine0 = spine[0];
      var tN = Math.min(3, sLen-1);
      var tDx = spine[tN].x - cSpine0.x, tDy = spine[tN].y - cSpine0.y;
      var tMag = Math.sqrt(tDx*tDx + tDy*tDy) || 1;
      var fwdX = -tDx/tMag, fwdY = -tDy/tMag; // forward direction
      var sideX = -fwdY, sideY = fwdX;
      var earSize = GRID * 0.45;

      // Ears (two triangles)
      ctx.fillStyle = '#f0c8a0';
      for (var ear = -1; ear <= 1; ear += 2) {
        var ebx = cSpine0.x + sideX * GRID * 0.3 * ear + fwdX * GRID * 0.1;
        var eby = cSpine0.y + sideY * GRID * 0.3 * ear + fwdY * GRID * 0.1;
        ctx.beginPath();
        ctx.moveTo(ebx - sideX * earSize * 0.3 * ear, eby - sideY * earSize * 0.3 * ear);
        ctx.lineTo(ebx + fwdX * earSize + sideX * earSize * 0.4 * ear, eby + fwdY * earSize + sideY * earSize * 0.4 * ear);
        ctx.lineTo(ebx + sideX * earSize * 0.4 * ear, eby + sideY * earSize * 0.4 * ear);
        ctx.closePath(); ctx.fill();
        // Inner ear (pink)
        ctx.fillStyle = '#e8a0a0';
        ctx.beginPath();
        ctx.moveTo(ebx - sideX * earSize * 0.15 * ear, eby - sideY * earSize * 0.15 * ear);
        ctx.lineTo(ebx + fwdX * earSize * 0.7 + sideX * earSize * 0.25 * ear, eby + fwdY * earSize * 0.7 + sideY * earSize * 0.25 * ear);
        ctx.lineTo(ebx + sideX * earSize * 0.25 * ear, eby + sideY * earSize * 0.25 * ear);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#f0c8a0';
      }
      // Eyes
      for (var ey = -1; ey <= 1; ey += 2) {
        var exx = cSpine0.x + sideX * GRID * 0.18 * ey + fwdX * GRID * 0.15;
        var eyy = cSpine0.y + sideY * GRID * 0.18 * ey + fwdY * GRID * 0.15;
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath(); ctx.arc(exx, eyy, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ffffff';
        ctx.beginPath(); ctx.arc(exx + fwdX * 0.8, eyy + fwdY * 0.8, 0.8, 0, Math.PI * 2); ctx.fill();
      }
      // Nose
      ctx.fillStyle = '#e07080';
      var nx = cSpine0.x + fwdX * GRID * 0.32;
      var ny = cSpine0.y + fwdY * GRID * 0.32;
      ctx.beginPath(); ctx.arc(nx, ny, 2, 0, Math.PI * 2); ctx.fill();
      // Whiskers
      ctx.strokeStyle = 'rgba(80,60,40,0.4)'; ctx.lineWidth = 0.7;
      for (var wh = -1; wh <= 1; wh += 2) {
        for (var wl = 0; wl < 2; wl++) {
          var whAng = (wl === 0 ? 0.15 : -0.15) * wh;
          var wx1 = nx + sideX * 3 * wh;
          var wy1 = ny + sideY * 3 * wh;
          var wx2 = wx1 + (fwdX * 0.3 + sideX * wh) * (8 + wl * 3) + fwdY * whAng * 5;
          var wy2 = wy1 + (fwdY * 0.3 + sideY * wh) * (8 + wl * 3) - fwdX * whAng * 5;
          ctx.beginPath(); ctx.moveTo(wx1, wy1); ctx.lineTo(wx2, wy2); ctx.stroke();
        }
      }
    } else if (sk.special === 'banane') {
      // â”€â”€ BANANA PEELED HEAD â”€â”€
      var bSpine0 = spine[0];
      var btN = Math.min(3, sLen-1);
      var btDx = spine[btN].x - bSpine0.x, btDy = spine[btN].y - bSpine0.y;
      var btMag = Math.sqrt(btDx*btDx + btDy*btDy) || 1;
      var bFwdX = -btDx/btMag, bFwdY = -btDy/btMag;
      var bSideX = -bFwdY, bSideY = bFwdX;
      var peelLen = GRID * 0.6;
      // 3 peel flaps curling outward
      var peelAngles = [-0.7, 0, 0.7];
      for (var pi = 0; pi < 3; pi++) {
        var pAng = peelAngles[pi];
        var pDirX = bFwdX * Math.cos(pAng) - bSideX * Math.sin(pAng);
        var pDirY = bFwdY * Math.cos(pAng) - bSideY * Math.sin(pAng);
        var pSdX = bFwdX * Math.sin(pAng) + bSideX * Math.cos(pAng);
        var pSdY = bFwdY * Math.sin(pAng) + bSideY * Math.cos(pAng);
        var p0x = bSpine0.x + bSideX*4*Math.sin(pAng);
        var p0y = bSpine0.y + bSideY*4*Math.sin(pAng);
        var p1x = p0x + pDirX*peelLen + pSdX*6;
        var p1y = p0y + pDirY*peelLen + pSdY*6;
        var p2x = p0x + pDirX*peelLen - pSdX*6;
        var p2y = p0y + pDirY*peelLen - pSdY*6;
        ctx.fillStyle = '#e8d030';
        ctx.beginPath(); ctx.moveTo(p0x, p0y); ctx.lineTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#f8f0c0';
        var inset = 0.15;
        ctx.beginPath();
        ctx.moveTo(p0x, p0y);
        ctx.lineTo(p0x+(p1x-p0x)*(1-inset), p0y+(p1y-p0y)*(1-inset));
        ctx.lineTo(p0x+(p2x-p0x)*(1-inset), p0y+(p2y-p0y)*(1-inset));
        ctx.closePath(); ctx.fill();
      }
      // Banana tip
      ctx.fillStyle = '#a08820';
      ctx.beginPath(); ctx.arc(bSpine0.x + bFwdX*GRID*0.3, bSpine0.y + bFwdY*GRID*0.3, 2.5, 0, Math.PI*2); ctx.fill();
    } else if (sk.special === 'diable') {
      // â”€â”€ DEVIL HORNS â”€â”€
      var dSpine0 = spine[0];
      var dtN = Math.min(3, sLen-1);
      var dtDx = spine[dtN].x - dSpine0.x, dtDy = spine[dtN].y - dSpine0.y;
      var dtMag = Math.sqrt(dtDx*dtDx + dtDy*dtDy) || 1;
      var dFwdX = -dtDx/dtMag, dFwdY = -dtDy/dtMag;
      var dSideX = -dFwdY, dSideY = dFwdX;
      var hornLen = GRID * 0.55;
      // Two curved horns
      for (var hi = -1; hi <= 1; hi += 2) {
        var hbx = dSpine0.x + dSideX*getW(0)*0.5*hi;
        var hby = dSpine0.y + dSideY*getW(0)*0.5*hi;
        var htx = hbx + dFwdX*hornLen + dSideX*hi*hornLen*0.6;
        var hty = hby + dFwdY*hornLen + dSideY*hi*hornLen*0.6;
        var hcpx = hbx + dFwdX*hornLen*0.7 + dSideX*hi*hornLen*0.2;
        var hcpy = hby + dFwdY*hornLen*0.7 + dSideY*hi*hornLen*0.2;
        ctx.strokeStyle = '#600808'; ctx.lineWidth = 3.5; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(hbx, hby); ctx.quadraticCurveTo(hcpx, hcpy, htx, hty); ctx.stroke();
        ctx.strokeStyle = '#a01010'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(hbx, hby); ctx.quadraticCurveTo(hcpx, hcpy, htx, hty); ctx.stroke();
        // Horn tip highlight
        ctx.fillStyle = '#ff4020';
        ctx.beginPath(); ctx.arc(htx, hty, 1.5, 0, Math.PI*2); ctx.fill();
      }
      // Standard glans underneath
      var cIdx = Math.floor(sLen * 0.13);
      if (cIdx < sLen) {
        ctx.strokeStyle = sk.corona; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.moveTo(leftPts[cIdx].x, leftPts[cIdx].y); ctx.lineTo(rightPts[cIdx].x, rightPts[cIdx].y); ctx.stroke();
      }
      var dtN2 = Math.min(3, sLen-1);
      var dtDx2 = spine[dtN2].x - spine[0].x, dtDy2 = spine[dtN2].y - spine[0].y;
      var dtMag2 = Math.sqrt(dtDx2*dtDx2 + dtDy2*dtDy2) || 1;
      var dtNx = -dtDy2/dtMag2, dtNy = dtDx2/dtMag2, dmL = GRID * 0.22;
      ctx.strokeStyle = sk.meatus; ctx.lineWidth = 2; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(spine[0].x+dtNx*dmL, spine[0].y+dtNy*dmL); ctx.lineTo(spine[0].x-dtNx*dmL, spine[0].y-dtNy*dmL); ctx.stroke();
    } else if (sk.special === 'knight') {
      // â”€â”€ KNIGHT HELMET HEAD â”€â”€
      var kSpine0 = spine[0];
      var ktN = Math.min(3, sLen-1);
      var ktDx = spine[ktN].x - kSpine0.x, ktDy = spine[ktN].y - kSpine0.y;
      var ktMag = Math.sqrt(ktDx*ktDx + ktDy*ktDy) || 1;
      var kFwdX = -ktDx/ktMag, kFwdY = -ktDy/ktMag;
      var kSideX = -kFwdY, kSideY = kFwdX;
      var hw = getW(0) * 1.1;
      // Helmet dome (darker steel)
      ctx.fillStyle = '#8a929a';
      ctx.beginPath();
      ctx.arc(kSpine0.x + kFwdX*2, kSpine0.y + kFwdY*2, hw*1.05, 0, Math.PI*2);
      ctx.fill();
      // Highlight
      ctx.fillStyle = 'rgba(200,210,220,0.4)';
      ctx.beginPath();
      ctx.arc(kSpine0.x + kFwdX*2 + kSideX*hw*0.2, kSpine0.y + kFwdY*2 + kSideY*hw*0.2, hw*0.5, 0, Math.PI*2);
      ctx.fill();
      // Visor slit (dark horizontal line)
      ctx.strokeStyle = '#2a2e35'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(kSpine0.x + kSideX*hw*0.65, kSpine0.y + kSideY*hw*0.65);
      ctx.lineTo(kSpine0.x - kSideX*hw*0.65, kSpine0.y - kSideY*hw*0.65);
      ctx.stroke();
      // Visor cross (vertical slit)
      ctx.strokeStyle = '#2a2e35'; ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.moveTo(kSpine0.x + kFwdX*hw*0.4, kSpine0.y + kFwdY*hw*0.4);
      ctx.lineTo(kSpine0.x - kFwdX*hw*0.15, kSpine0.y - kFwdY*hw*0.15);
      ctx.stroke();
      // Rim
      ctx.strokeStyle = 'rgba(180,190,200,0.5)'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(kSpine0.x + kFwdX*2, kSpine0.y + kFwdY*2, hw*1.05, 0, Math.PI*2);
      ctx.stroke();
    } else {
      // â”€â”€ STANDARD GLANS â”€â”€
      var cIdx = Math.floor(sLen * 0.13);
      if (cIdx < sLen) {
        ctx.strokeStyle = sk.corona; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.moveTo(leftPts[cIdx].x, leftPts[cIdx].y); ctx.lineTo(rightPts[cIdx].x, rightPts[cIdx].y); ctx.stroke();
        ctx.strokeStyle = 'rgba(225,175,185,0.3)'; ctx.lineWidth = 1.2;
        var c2 = Math.max(cIdx-2, 0);
        ctx.beginPath(); ctx.moveTo(leftPts[c2].x, leftPts[c2].y); ctx.lineTo(rightPts[c2].x, rightPts[c2].y); ctx.stroke();
      }
      // Meatus
      var tN = Math.min(3, sLen-1);
      var tDx = spine[tN].x - spine[0].x, tDy = spine[tN].y - spine[0].y;
      var tMag = Math.sqrt(tDx*tDx + tDy*tDy) || 1;
      var tNx = -tDy/tMag, tNy = tDx/tMag, mL = GRID * 0.22;
      ctx.strokeStyle = sk.meatus; ctx.lineWidth = 2; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(spine[0].x+tNx*mL, spine[0].y+tNy*mL); ctx.lineTo(spine[0].x-tNx*mL, spine[0].y-tNy*mL); ctx.stroke();
      ctx.strokeStyle = 'rgba(90,35,45,0.2)'; ctx.lineWidth = 4.5;
      ctx.beginPath(); ctx.moveTo(spine[0].x+tNx*mL*0.5, spine[0].y+tNy*mL*0.5); ctx.lineTo(spine[0].x-tNx*mL*0.5, spine[0].y-tNy*mL*0.5); ctx.stroke();
    }
  }

  // â”€â”€ TESTICLES (only for tail segment) â”€â”€
  if (isTail && sLen > 10) {
    var tailIdx = sLen - 1;
    var tPt = spine[tailIdx];
    var prT = spine[Math.max(tailIdx - 12, 0)];
    var tdx2 = tPt.x - prT.x, tdy2 = tPt.y - prT.y;
    var tm = Math.sqrt(tdx2*tdx2 + tdy2*tdy2) || 1;
    var dirX = tdx2/tm, dirY = tdy2/tm;
    var tnx = -dirY, tny = dirX;

    var bR = GRID * 0.77;
    var spread2 = bR * 0.72;
    var drop2 = bR * 0.05;

    var b1 = { x: tPt.x + dirX*drop2 + tnx*spread2, y: tPt.y + dirY*drop2 + tny*spread2 };
    var b2 = { x: tPt.x + dirX*drop2 - tnx*spread2, y: tPt.y + dirY*drop2 - tny*spread2 };
    var bAng = Math.atan2(dirY, dirX) + Math.PI/2;
    var blendIdx = Math.max(0, Math.floor(sLen * 0.82));

    var balls = [b1, b2];
    // Tchernobyl: mutant 3rd ball
    if (sk.special === 'tchernobyl') {
      var b3 = { x: tPt.x + dirX*(drop2 + bR*0.9), y: tPt.y + dirY*(drop2 + bR*0.9) };
      balls.push(b3);
    }
    for (var bi = 0; bi < balls.length; bi++) {
      var ball = balls[bi];
      var side = bi === 0 ? 1 : (bi === 1 ? -1 : 0);
      var curBR = (bi === 2) ? bR * 0.7 : bR; // 3rd ball smaller
      ctx.fillStyle = 'rgba(30,15,10,0.25)';
      ctx.beginPath(); ctx.ellipse(ball.x+3, ball.y+4, curBR*0.92, curBR*1.02, bAng, 0, Math.PI*2); ctx.fill();
      var mg = ctx.createRadialGradient(ball.x-tnx*side*curBR*0.25-dirX*curBR*0.25, ball.y-tny*side*curBR*0.25-dirY*curBR*0.25, curBR*0.05, ball.x, ball.y, curBR);
      mg.addColorStop(0,sk.ballGrad[0]); mg.addColorStop(0.25,sk.ballGrad[1]); mg.addColorStop(0.5,sk.ballGrad[2]); mg.addColorStop(0.75,sk.ballGrad[3]); mg.addColorStop(1,sk.ballGrad[4]);
      ctx.fillStyle=mg; ctx.beginPath(); ctx.ellipse(ball.x, ball.y, curBR*0.88, curBR, bAng, 0, Math.PI*2); ctx.fill();
      var hl = ctx.createRadialGradient(ball.x-tnx*side*curBR*0.2-dirX*curBR*0.3, ball.y-tny*side*curBR*0.2-dirY*curBR*0.3, curBR*0.02, ball.x-tnx*side*curBR*0.1-dirX*curBR*0.15, ball.y-tny*side*curBR*0.1-dirY*curBR*0.15, curBR*0.7);
      hl.addColorStop(0,'rgba(255,250,240,0.5)'); hl.addColorStop(0.3,'rgba(255,240,225,0.28)'); hl.addColorStop(0.7,'rgba(255,230,210,0.08)'); hl.addColorStop(1,'rgba(255,220,200,0)');
      ctx.fillStyle=hl; ctx.beginPath(); ctx.ellipse(ball.x, ball.y, curBR*0.88, curBR, bAng, 0, Math.PI*2); ctx.fill();
      var bs = ctx.createRadialGradient(ball.x+dirX*curBR*0.5, ball.y+dirY*curBR*0.5, curBR*0.1, ball.x+dirX*curBR*0.3, ball.y+dirY*curBR*0.3, curBR);
      bs.addColorStop(0,'rgba(70,40,25,0.3)'); bs.addColorStop(0.5,'rgba(70,40,25,0.1)'); bs.addColorStop(1,'rgba(70,40,25,0)');
      ctx.fillStyle=bs; ctx.beginPath(); ctx.ellipse(ball.x+dirX*curBR*0.15, ball.y+dirY*curBR*0.15, curBR*0.85, curBR*0.95, bAng, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.35)'; ctx.beginPath();
      ctx.ellipse(ball.x-tnx*side*curBR*0.22-dirX*curBR*0.32, ball.y-tny*side*curBR*0.22-dirY*curBR*0.32, curBR*0.15, curBR*0.1, bAng-0.4*side, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(140,95,70,0.22)'; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.ellipse(ball.x, ball.y, curBR*0.88, curBR, bAng, 0, Math.PI*2); ctx.stroke();
      ctx.strokeStyle='rgba(155,110,85,0.1)'; ctx.lineWidth=0.7;
      for(var ww=-2;ww<=2;ww++){
        ctx.beginPath(); ctx.arc(ball.x+dirX*ww*curBR*0.07, ball.y+dirY*ww*curBR*0.07, curBR*0.65, bAng-0.6, bAng+0.6); ctx.stroke();
      }
    }
    // Skin bridge
    var skinGrd = ctx.createLinearGradient(tPt.x-tnx*spread2, tPt.y-tny*spread2, tPt.x+tnx*spread2, tPt.y+tny*spread2);
    skinGrd.addColorStop(0,sk.ballBridge[0]); skinGrd.addColorStop(0.5,sk.ballBridge[1]); skinGrd.addColorStop(1,sk.ballBridge[2]);
    ctx.fillStyle=skinGrd; ctx.beginPath();
    ctx.moveTo(leftPts[blendIdx].x, leftPts[blendIdx].y);
    for(i=blendIdx;i<=tailIdx;i++) ctx.lineTo(leftPts[i].x, leftPts[i].y);
    ctx.bezierCurveTo(tPt.x+tnx*spread2*0.5-dirX*bR*0.3, tPt.y+tny*spread2*0.5-dirY*bR*0.3, b1.x-dirX*bR*0.6, b1.y-dirY*bR*0.6, b1.x-dirX*bR*0.2+tnx*bR*0.3, b1.y-dirY*bR*0.2+tny*bR*0.3);
    ctx.bezierCurveTo(tPt.x-dirX*bR*0.5+tnx*spread2*0.3, tPt.y-dirY*bR*0.5+tny*spread2*0.3, tPt.x-dirX*bR*0.5-tnx*spread2*0.3, tPt.y-dirY*bR*0.5-tny*spread2*0.3, b2.x-dirX*bR*0.2-tnx*bR*0.3, b2.y-dirY*bR*0.2-tny*bR*0.3);
    ctx.bezierCurveTo(b2.x-dirX*bR*0.6, b2.y-dirY*bR*0.6, tPt.x-tnx*spread2*0.5-dirX*bR*0.3, tPt.y-tny*spread2*0.5-dirY*bR*0.3, rightPts[tailIdx].x, rightPts[tailIdx].y);
    for(i=tailIdx;i>=blendIdx;i--) ctx.lineTo(rightPts[i].x, rightPts[i].y);
    ctx.closePath(); ctx.fill();
    // Bridge shading
    var bsh = ctx.createLinearGradient(tPt.x+tnx*spread2, tPt.y+tny*spread2, tPt.x-tnx*spread2, tPt.y-tny*spread2);
    bsh.addColorStop(0,'rgba(255,235,215,0.15)'); bsh.addColorStop(0.35,'rgba(0,0,0,0)'); bsh.addColorStop(0.65,'rgba(0,0,0,0)'); bsh.addColorStop(1,'rgba(0,0,0,0.12)');
    ctx.fillStyle=bsh; ctx.beginPath();
    ctx.moveTo(leftPts[tailIdx].x,leftPts[tailIdx].y);
    ctx.lineTo(b1.x-dirX*bR*0.3, b1.y-dirY*bR*0.3);
    ctx.lineTo(b2.x-dirX*bR*0.3, b2.y-dirY*bR*0.3);
    ctx.lineTo(rightPts[tailIdx].x,rightPts[tailIdx].y);
    ctx.closePath(); ctx.fill();
    // Raphe
    var mid = {x:(b1.x+b2.x)/2, y:(b1.y+b2.y)/2};
    ctx.strokeStyle='rgba(100,60,40,0.18)'; ctx.lineWidth=3.5; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(tPt.x, tPt.y);
    ctx.bezierCurveTo(mid.x,mid.y, mid.x+dirX*bR*0.4,mid.y+dirY*bR*0.4, mid.x+dirX*bR*0.85,mid.y+dirY*bR*0.85); ctx.stroke();
    ctx.strokeStyle='rgba(150,105,80,0.22)'; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(tPt.x-dirX*bR*0.1, tPt.y-dirY*bR*0.1);
    ctx.bezierCurveTo(mid.x-dirX*bR*0.1,mid.y-dirY*bR*0.1, mid.x+dirX*bR*0.5,mid.y+dirY*bR*0.5, mid.x+dirX*bR*0.9,mid.y+dirY*bR*0.9); ctx.stroke();

    // â”€â”€ PUBIC HAIR (Le Sauvage) â”€â”€
    if (sk.hairy) {
      ctx.lineCap = 'round';
      for (var hi = 0; hi < 100; hi++) {
        var hBall = balls[Math.floor(Math.random() * 2)];
        var hAng2 = Math.random() * Math.PI * 2;
        var hDist = bR * (0.2 + Math.random() * 0.7);
        var hbx = hBall.x + Math.cos(hAng2) * hDist * 0.88;
        var hby = hBall.y + Math.sin(hAng2) * hDist;
        var hLen2 = 6 + Math.random() * 12;
        var hDir = hAng2 + (Math.random() - 0.5) * 1.0;
        var htx = hbx + Math.cos(hDir) * hLen2;
        var hty = hby + Math.sin(hDir) * hLen2;
        var hAlpha = 0.4 + Math.random() * 0.4;
        ctx.strokeStyle = 'rgba(30,15,5,' + hAlpha + ')';
        ctx.lineWidth = 0.5 + Math.random() * 1.1;
        ctx.beginPath(); ctx.moveTo(hbx, hby);
        ctx.quadraticCurveTo(
          (hbx+htx)/2 + (Math.random()-0.5)*6,
          (hby+hty)/2 + (Math.random()-0.5)*6,
          htx, hty
        );
        ctx.stroke();
      }
    }
  }
}

function draw() {
  var now = performance.now();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // â”€â”€ THEME BACKGROUND â”€â”€
  var th = THEMES[currentTheme];
  if (th) {
    var bgG = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgG.addColorStop(0, th.bg1); bgG.addColorStop(1, th.bg2);
    ctx.fillStyle = bgG; ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Grid lines
    ctx.strokeStyle = th.grid; ctx.lineWidth = 0.5;
    for (var gx = 0; gx < canvas.width; gx += GRID) {
      ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
    }
    for (var gy = 0; gy < canvas.height; gy += GRID) {
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
    }
    // Stars effect
    if (th.stars) {
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      for (var si3 = 0; si3 < 60; si3++) {
        var sx = (si3*137.5+50)%canvas.width, sy = (si3*97.3+30)%canvas.height;
        var sBr = 0.3 + Math.sin(now*0.002+si3)*0.3;
        ctx.globalAlpha = sBr; ctx.beginPath(); ctx.arc(sx, sy, 1, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
    // Nebula effect
    if (th.nebula) {
      var nbx = canvas.width*0.3 + Math.sin(now*0.0003)*50;
      var nby = canvas.height*0.4 + Math.cos(now*0.0004)*30;
      var nbG = ctx.createRadialGradient(nbx, nby, 0, nbx, nby, 150);
      nbG.addColorStop(0, 'rgba(100,40,180,0.08)'); nbG.addColorStop(1, 'rgba(100,40,180,0)');
      ctx.fillStyle = nbG; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    // Lava effect
    if (th.lava) {
      for (var lv = 0; lv < 5; lv++) {
        var lvx = (lv*120+Math.sin(now*0.001+lv)*30)%canvas.width;
        var lvy = canvas.height - 10 + Math.sin(now*0.003+lv*2)*8;
        var lvG = ctx.createRadialGradient(lvx, lvy, 0, lvx, lvy, 40);
        lvG.addColorStop(0, 'rgba(255,80,20,0.12)'); lvG.addColorStop(1, 'rgba(255,40,10,0)');
        ctx.fillStyle = lvG; ctx.beginPath(); ctx.arc(lvx, lvy, 40, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  var len = smoothSnake.length;
  if (len < 2) return;
  var skNow = SKINS[currentSkin];

  // â”€â”€ ESCARGOT SLIME TRAIL â”€â”€
  if (skNow.special === 'escargot' && slimeTrail.length > 1) {
    for (var si2 = 0; si2 < slimeTrail.length; si2++) {
      var age = (now - slimeTrail[si2].t) / 5000;
      if (age > 1) continue;
      var al = (1 - age) * 0.25;
      var sz = 6 + (1 - age) * 4;
      ctx.fillStyle = 'rgba(140,200,80,' + al + ')';
      ctx.beginPath(); ctx.arc(slimeTrail[si2].x, slimeTrail[si2].y, sz, 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ GLACÃ‰ FROST TRAIL â”€â”€
  if (skNow.special === 'glace' && frostTrail.length > 1) {
    for (var fi2 = 0; fi2 < frostTrail.length; fi2++) {
      var fAge = (now - frostTrail[fi2].t) / 4000;
      if (fAge > 1) continue;
      var fAl = (1 - fAge) * 0.35;
      var fSz = 3 + (1 - fAge) * 3;
      // Ice crystal (small diamond shape)
      ctx.fillStyle = 'rgba(180,220,255,' + fAl + ')';
      ctx.save(); ctx.translate(frostTrail[fi2].x, frostTrail[fi2].y);
      ctx.rotate(fi2 * 0.7);
      ctx.beginPath(); ctx.moveTo(0,-fSz); ctx.lineTo(fSz*0.6,0); ctx.lineTo(0,fSz); ctx.lineTo(-fSz*0.6,0); ctx.closePath(); ctx.fill();
      ctx.restore();
      // Sparkle
      if (fi2 % 4 === 0) {
        var spAl = fAl * (0.5 + Math.sin(now*0.01+fi2)*0.3);
        ctx.fillStyle = 'rgba(220,240,255,' + spAl + ')';
        ctx.beginPath(); ctx.arc(frostTrail[fi2].x, frostTrail[fi2].y, 1.5, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  // â”€â”€ DIABLE FLAME PARTICLES â”€â”€
  if (skNow.special === 'diable' && flameParticles.length > 0) {
    for (var fp = 0; fp < flameParticles.length; fp++) {
      var fl = flameParticles[fp];
      var fElapsed = (now - fl.t) / 1000;
      var fLife = fElapsed / fl.life;
      if (fLife > 1) continue;
      var fx = fl.x + fl.vx * fElapsed * 30;
      var fy = fl.y + fl.vy * fElapsed * 30;
      var fAlpha = (1 - fLife) * 0.7;
      var fSize = (1 - fLife) * 5 + 2;
      // Gradient: yellow â†’ orange â†’ red as it ages
      var r = 255, g = Math.floor(200 - fLife * 150), b = Math.floor(50 - fLife * 50);
      ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + Math.max(0,b) + ',' + fAlpha + ')';
      ctx.beginPath(); ctx.arc(fx, fy, fSize, 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ ALIEN GLOW â”€â”€
  if (skNow.special === 'alien') {
    for (var ag = 0; ag < smoothSnake.length; ag += 3) {
      var gx = smoothSnake[ag].x, gy = smoothSnake[ag].y;
      var gPulse = 0.15 + Math.sin(now * 0.004 + ag * 0.3) * 0.08;
      var gR = GRID * 1.2;
      var gG = ctx.createRadialGradient(gx, gy, 0, gx, gy, gR);
      gG.addColorStop(0, 'rgba(0,255,130,' + gPulse + ')');
      gG.addColorStop(1, 'rgba(0,255,130,0)');
      ctx.fillStyle = gG; ctx.beginPath(); ctx.arc(gx, gy, gR, 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ TCHERNOBYL RADIOACTIVE GLOW â”€â”€
  if (skNow.special === 'tchernobyl') {
    for (var tg = 0; tg < smoothSnake.length; tg += 3) {
      var tx = smoothSnake[tg].x, ty = smoothSnake[tg].y;
      var tPulse = 0.12 + Math.sin(now * 0.003 + tg * 0.4) * 0.08;
      var tR = GRID * 1.1;
      var tGr = ctx.createRadialGradient(tx, ty, 0, tx, ty, tR);
      tGr.addColorStop(0, 'rgba(180,220,30,' + tPulse + ')');
      tGr.addColorStop(0.5, 'rgba(120,180,20,' + (tPulse*0.5) + ')');
      tGr.addColorStop(1, 'rgba(80,140,10,0)');
      ctx.fillStyle = tGr; ctx.beginPath(); ctx.arc(tx, ty, tR, 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ GLACÃ‰ ICY SHIMMER â”€â”€
  if (skNow.special === 'glace') {
    for (var ig = 0; ig < smoothSnake.length; ig += 4) {
      var ix = smoothSnake[ig].x, iy = smoothSnake[ig].y;
      var iPulse = 0.08 + Math.sin(now * 0.005 + ig * 0.5) * 0.05;
      var iR = GRID * 0.9;
      var iGr = ctx.createRadialGradient(ix, iy, 0, ix, iy, iR);
      iGr.addColorStop(0, 'rgba(180,220,255,' + iPulse + ')');
      iGr.addColorStop(1, 'rgba(180,220,255,0)');
      ctx.fillStyle = iGr; ctx.beginPath(); ctx.arc(ix, iy, iR, 0, Math.PI*2); ctx.fill();
    }
  }

  // Split snake into continuous segments (break at wrap points)
  var segments = getSegments(smoothSnake);

  // Draw each segment â€” tail segments first (back to front)
  for (var si = segments.length - 1; si >= 0; si--) {
    var seg = segments[si];
    var isHead = (si === 0);
    var isTail = (si === segments.length - 1);
    drawBodySegment(seg, len, isHead, isTail, now);
  }

  // â”€â”€ OBSTACLES (skulls only) â”€â”€
  var now = performance.now();
  for (var oi = 0; oi < obstacles.length; oi++) {
    var obs = obstacles[oi];
    var ox = obs.x * GRID + GRID/2, oy = obs.y * GRID + GRID/2;
    var fadeIn = Math.min(1, (now - obs.spawnTime) / 500);

    var intensity = Math.min(1, obs.level * 0.15);
    var pulse = 1 + Math.sin(now * 0.005 + obs.x * 0.5) * (0.08 + intensity * 0.08);
    var sG = ctx.createRadialGradient(ox, oy, 2, ox, oy, GRID*1.4*pulse);
    sG.addColorStop(0, 'rgba(200,30,200,' + ((0.25+intensity*0.15)*fadeIn) + ')');
    sG.addColorStop(0.5, 'rgba(150,10,150,' + (0.1*fadeIn) + ')'); sG.addColorStop(1, 'rgba(120,0,120,0)');
    ctx.fillStyle=sG; ctx.beginPath(); ctx.arc(ox, oy, GRID*1.4*pulse, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=fadeIn; ctx.save(); ctx.translate(ox, oy); ctx.scale(pulse, pulse);
    ctx.drawImage(skullCanvas, -20, -20, 40, 40); ctx.restore(); ctx.globalAlpha=1;

    if (now - obs.spawnTime < 600) {
      var flash = 1 - (now - obs.spawnTime) / 600;
      ctx.fillStyle = 'rgba(255,255,255,' + (flash * 0.4) + ')';
      ctx.beginPath(); ctx.arc(ox, oy, GRID * 0.8 * (1 + flash), 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ PEACH FOOD â”€â”€
  var fx=food.x*GRID+GRID/2, fy=food.y*GRID+GRID/2;
  var fG=ctx.createRadialGradient(fx,fy,2,fx,fy,GRID*1.1);
  fG.addColorStop(0,'rgba(255,180,120,0.3)'); fG.addColorStop(1,'rgba(255,180,120,0)');
  ctx.fillStyle=fG; ctx.beginPath(); ctx.arc(fx,fy,GRID*1.1,0,Math.PI*2); ctx.fill();
  ctx.drawImage(peachCanvas, fx-20, fy-20, 40, 40);

  // â”€â”€ GOLDEN BONUS PEACH â”€â”€
  if (bonusFood) {
    var bx=bonusFood.x*GRID+GRID/2, by=bonusFood.y*GRID+GRID/2;
    var bpulse = 1 + Math.sin(now * 0.004) * 0.2;
    var glowR = GRID * 1.5 * bpulse;
    var bG2=ctx.createRadialGradient(bx,by,2,bx,by,glowR);
    bG2.addColorStop(0,'rgba(255,215,0,0.45)'); bG2.addColorStop(0.4,'rgba(255,200,0,0.2)'); bG2.addColorStop(1,'rgba(255,180,0,0)');
    ctx.fillStyle=bG2; ctx.beginPath(); ctx.arc(bx,by,glowR,0,Math.PI*2); ctx.fill();

    var iG=ctx.createRadialGradient(bx,by,0,bx,by,GRID*0.8);
    iG.addColorStop(0,'rgba(255,255,255,0.25)'); iG.addColorStop(1,'rgba(255,255,200,0)');
    ctx.fillStyle=iG; ctx.beginPath(); ctx.arc(bx,by,GRID*0.8,0,Math.PI*2); ctx.fill();

    ctx.save(); ctx.translate(bx, by);
    var sc = 1 + Math.sin(now * 0.005) * 0.06;
    ctx.scale(sc, sc); ctx.drawImage(goldenPeachCanvas, -20, -20, 40, 40); ctx.restore();

    for (var si = 0; si < 5; si++) {
      var sAngle = now * 0.003 + si * Math.PI * 2 / 5;
      var sDist = GRID * 0.7 + Math.sin(now * 0.006 + si * 2) * 4;
      var sx = bx + Math.cos(sAngle) * sDist, sy = by + Math.sin(sAngle) * sDist;
      var sparkAlpha = 0.5 + Math.sin(now * 0.008 + si * 1.5) * 0.4;
      var sparkSize = 2 + Math.sin(now * 0.01 + si) * 1.2;
      ctx.fillStyle = 'rgba(255,255,200,' + sparkAlpha + ')';
      ctx.beginPath(); ctx.arc(sx, sy, sparkSize, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,240,150,' + (sparkAlpha * 0.6) + ')'; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(sx-sparkSize*2, sy); ctx.lineTo(sx+sparkSize*2, sy);
      ctx.moveTo(sx, sy-sparkSize*2); ctx.lineTo(sx, sy+sparkSize*2); ctx.stroke();
    }
    ctx.font='bold 11px sans-serif'; ctx.fillStyle='rgba(255,230,100,0.9)';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('x2', bx, by-GRID*0.85);
  }

  // â”€â”€ COIN â”€â”€
  if (coin) {
    var cx3 = coin.x*GRID+GRID/2, cy3 = coin.y*GRID+GRID/2;
    var coinAge = now - coin.spawnTime;
    var coinAlpha = 1;
    // Blink in last 1.5s
    if (coinAge > COIN_LIFETIME - 1500) {
      coinAlpha = 0.3 + 0.7 * Math.abs(Math.sin(coinAge * 0.012));
    }
    ctx.save();
    ctx.globalAlpha = coinAlpha;
    // Glow
    var cG = ctx.createRadialGradient(cx3,cy3,2,cx3,cy3,GRID*1.3);
    cG.addColorStop(0,'rgba(255,215,0,0.4)'); cG.addColorStop(0.5,'rgba(255,200,0,0.15)'); cG.addColorStop(1,'rgba(255,180,0,0)');
    ctx.fillStyle = cG; ctx.beginPath(); ctx.arc(cx3,cy3,GRID*1.3,0,Math.PI*2); ctx.fill();
    // Spin effect (squash X)
    var spinScale = 0.4 + 0.6 * Math.abs(Math.cos(now * 0.004));
    ctx.translate(cx3, cy3);
    ctx.scale(spinScale, 1);
    ctx.drawImage(coinCanvas, -20, -20, 40, 40);
    ctx.restore();
  }

  drawParticles();

  if (screenFlash > 0) {
    ctx.fillStyle = 'rgba(255,50,50,' + (screenFlash*0.15) + ')';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    screenFlash *= 0.92;
    if (screenFlash < 0.01) screenFlash = 0;
  }

  if (levelUpText.active) {
    var elapsed = (now - levelUpText.time) / 1000;
    if (elapsed > 2.5) { levelUpText.active = false; }
    else {
      var al = elapsed < 0.3 ? elapsed / 0.3 : elapsed > 2 ? 1 - (elapsed - 2) / 0.5 : 1;
      var scl = elapsed < 0.3 ? 0.5 + elapsed / 0.3 * 0.5 : 1;
      var yy = canvas.height * 0.18 - elapsed * 8;
      ctx.save(); ctx.translate(canvas.width / 2, yy); ctx.scale(scl, scl);
      ctx.font='bold 28px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(255,200,50,' + (al*0.3) + ')';
      ctx.fillText('\u26A0 NIVEAU ' + levelUpText.level + ' \u26A0', 2, 2);
      ctx.fillStyle='rgba(255,220,80,' + al + ')';
      ctx.fillText('\u26A0 NIVEAU ' + levelUpText.level + ' \u26A0', 0, 0);
      ctx.font='14px sans-serif'; ctx.fillStyle='rgba(255,180,100,' + (al*0.8) + ')';
      ctx.fillText(obstacles.length + ' \uD83D\uDC80', 0, 30);
      ctx.restore();
    }
  }

  if (obstacles.length > 0) {
    ctx.font='11px sans-serif'; ctx.textAlign='right'; ctx.textBaseline='bottom';
    ctx.fillStyle='rgba(255,255,255,0.25)';
    ctx.fillText('\uD83D\uDC80' + obstacles.length, canvas.width - 8, canvas.height - 6);
  }

  // â”€â”€ BONUS HUD (top-left) â”€â”€
  var hudY = 14, hudX = 8;
  ctx.font = '12px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';

  // â”€â”€ MUTE BUTTON (top-right) â”€â”€
  ctx.font = '20px sans-serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText(soundMuted ? 'ğŸ”‡' : 'ğŸ”Š', canvas.width - 10, 8);

  ctx.font = '12px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
  if (shieldActive) {
    ctx.fillStyle = 'rgba(100,200,255,0.85)';
    ctx.fillText('ğŸ›¡ï¸ Capote', hudX, hudY); hudY += 16;
  }
  if (ghostActive) {
    var ghostSec = Math.ceil(ghostTimer / 1000);
    var ghostAlpha = 0.5 + Math.sin(now * 0.008) * 0.3;
    ctx.fillStyle = 'rgba(200,200,255,' + ghostAlpha + ')';
    ctx.fillText('ğŸ‘» FantÃ´me ' + ghostSec + 's', hudX, hudY); hudY += 16;
  }
  if (magnetActive) {
    ctx.fillStyle = 'rgba(255,180,80,0.85)';
    ctx.fillText('ğŸ§² Aimant', hudX, hudY); hudY += 16;
  }
  if (doubleActive) {
    ctx.fillStyle = 'rgba(255,230,80,0.85)';
    ctx.fillText('â­ x2', hudX, hudY); hudY += 16;
  }
  if (rainActive) {
    ctx.fillStyle = 'rgba(255,215,0,0.85)';
    ctx.fillText('ğŸ’° Pluie', hudX, hudY); hudY += 16;
  }

  // â”€â”€ BOSS RENDERING â”€â”€
  if (boss) {
    var bpx2 = boss.x * GRID + GRID/2, bpy2 = boss.y * GRID + GRID/2;
    var bPulse2 = 1 + Math.sin(now * 0.005) * 0.15;
    var bSize = GRID * boss.size * bPulse2;
    // Danger aura
    var bAura = ctx.createRadialGradient(bpx2, bpy2, bSize*0.3, bpx2, bpy2, bSize*1.5);
    bAura.addColorStop(0, 'rgba(255,30,30,0.25)'); bAura.addColorStop(1, 'rgba(255,30,30,0)');
    ctx.fillStyle = bAura; ctx.beginPath(); ctx.arc(bpx2, bpy2, bSize*1.5, 0, Math.PI*2); ctx.fill();
    // Boss body
    ctx.font = (GRID * boss.size) + 'px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ‘¹', bpx2, bpy2);
    // HP bar
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(bpx2-20, bpy2-bSize-8, 40, 6);
    ctx.fillStyle = boss.hp >= 2 ? '#40ff40' : '#ff4040';
    ctx.fillRect(bpx2-20, bpy2-bSize-8, 40*(boss.hp/3), 6);
  }

  // â”€â”€ BOSS WARNING â”€â”€
  if (bossWarning > 0 && now - bossWarning < 2000) {
    var wProg = (now - bossWarning) / 2000;
    var wAl = Math.sin(wProg * Math.PI * 6) * 0.3;
    if (wAl > 0) {
      ctx.fillStyle = 'rgba(255,0,0,' + wAl + ')';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.font = 'bold 24px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(255,50,50,' + (1-wProg) + ')';
    ctx.fillText('âš ï¸ BOSS INCOMING âš ï¸', canvas.width/2, canvas.height*0.15);
  }

  // â”€â”€ COMBO DISPLAY â”€â”€
  if (comboDisplay && combo >= 2) {
    var cElapsed = (now - comboDisplay.time) / 1000;
    if (cElapsed < 1.5) {
      var cAl = cElapsed < 0.2 ? cElapsed/0.2 : (cElapsed > 1 ? 1-(cElapsed-1)/0.5 : 1);
      var cScale = 1 + Math.min(combo * 0.1, 0.8);
      ctx.save();
      ctx.translate(canvas.width/2, canvas.height*0.25 - cElapsed*20);
      ctx.scale(cScale, cScale);
      ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(255,100,50,' + (cAl*0.3) + ')';
      ctx.fillText('ğŸ”¥ COMBO x' + comboDisplay.count, 2, 2);
      ctx.fillStyle = 'rgba(255,180,50,' + cAl + ')';
      ctx.fillText('ğŸ”¥ COMBO x' + comboDisplay.count, 0, 0);
      ctx.restore();
    }
  }

  // â”€â”€ CHRONO/SURVIVAL TIMER â”€â”€
  if (gameMode === 'chrono') {
    var cSec = Math.ceil(chronoTimer / 1000);
    ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillStyle = cSec <= 10 ? 'rgba(255,80,80,0.9)' : 'rgba(255,255,255,0.7)';
    ctx.fillText('â±ï¸ ' + cSec + 's', canvas.width/2, 6);
  }
  if (gameMode === 'survival') {
    var sSec = Math.floor(survivalTimer / 1000);
    ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillStyle = 'rgba(255,100,100,0.8)';
    ctx.fillText('ğŸ’€ Survie: ' + sSec + 's', canvas.width/2, 6);
  }

  // â”€â”€ ACHIEVEMENT POPUP â”€â”€
  if (achievementPopup) {
    var apElapsed = (now - achievementPopup.time) / 1000;
    if (apElapsed > 3) { achievementPopup = null; }
    else {
      var apAl = apElapsed < 0.3 ? apElapsed/0.3 : (apElapsed > 2.5 ? 1-(apElapsed-2.5)/0.5 : 1);
      var apY = canvas.height - 50 - (apElapsed < 0.3 ? (1-apElapsed/0.3)*20 : 0);
      ctx.globalAlpha = apAl;
      ctx.fillStyle = 'rgba(40,35,60,0.9)';
      ctx.beginPath();
      var apW = 180, apH = 36;
      var apX = canvas.width/2 - apW/2;
      ctx.fillRect(apX, apY-apH/2, apW, apH); ctx.fill();
      ctx.strokeStyle = 'rgba(240,192,64,0.6)'; ctx.lineWidth = 1.5;
      ctx.strokeRect(apX, apY-apH/2, apW, apH);
      ctx.font = '13px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = '#f0c040';
      ctx.fillText('ğŸ… ' + achievementPopup.icon + ' ' + achievementPopup.name + ' !', canvas.width/2, apY);
      ctx.globalAlpha = 1;
    }
  }

  // Ghost visual effect on snake
  if (ghostActive) {
    ctx.globalAlpha = 0.12 + Math.sin(now * 0.006) * 0.08;
    ctx.fillStyle = '#aaddff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;
  }
}
</script>
<div class="copyright">Â© 2025 Snaked â€” Tous droits rÃ©servÃ©s</div>
</body>
</html>
