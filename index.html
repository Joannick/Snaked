<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ğŸ† Snaked</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html {
    overflow: hidden;
    width: 100%;
    height: 100%;
  }
  body {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    overscroll-behavior: none;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background: #1a1a2e;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-height: 100vh; min-height: 100dvh;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    color: #e0e0e0;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }
  h1 {
    font-size: 1.8rem; margin-bottom: 6px;
    background: linear-gradient(135deg, #e8a0bf, #d4789c);
    -webkit-background-clip: text; background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .score-bar {
    display: flex; margin-bottom: 8px; font-size: 1rem;
  }
  .score-bar span { color: #ccc; margin: 0 12px; }
  .score-bar strong { color: #f0c040; }
  .game-wrap {
    position: relative; display: inline-block;
    max-width: 95vw; max-height: 55vh;
  }
  canvas {
    display: block;
    border: 3px solid #3a3a5c; border-radius: 8px; background: #16213e;
    box-shadow: 0 0 30px rgba(200,100,150,0.15);
    touch-action: none;
    max-width: 95vw; max-height: 55vh;
    width: auto; height: auto;
  }
  .controls { margin-top: 10px; font-size: 0.85rem; color: #888; }
  .overlay {
    position: absolute; top:0;left:0;right:0;bottom:0; background: rgba(0,0,0,0.75);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 10; border-radius: 8px;
    touch-action: manipulation;
  }
  .overlay h2 { font-size: 2.2rem; color: #f0c040; margin-bottom: 8px; }
  .overlay p { font-size: 1.1rem; color: #ccc; margin-bottom: 14px; text-align: center; padding: 0 10px; }
  .overlay .play-btn {
    padding: 14px 40px; font-size: 1.1rem; border: none; border-radius: 25px;
    background: linear-gradient(135deg, #d4789c, #c0507a); color: white;
    cursor: pointer; touch-action: manipulation; -webkit-appearance: none;
    appearance: none; font-weight: 600; letter-spacing: 0.5px;
  }
  .overlay .play-btn:active { transform: scale(0.96); opacity: 0.9; }
  .control-choice {
    display: flex; margin-bottom: 14px;
  }
  .control-choice button {
    padding: 12px 22px; font-size: 0.95rem; border: 2px solid #555; border-radius: 15px;
    background: rgba(255,255,255,0.05); color: #ddd; cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    display: flex; flex-direction: column; align-items: center;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    margin: 0 6px;
  }
  .control-choice button .icon { font-size: 1.6rem; margin-bottom: 4px; display: block; }
  .control-choice button:active { opacity: 0.8; }
  .control-choice button.selected { border-color: #f0c040; background: rgba(240,192,64,0.15); color: #f0c040; }

  /* Arrow controls */
  .mobile-controls {
    display: none; margin-top: 12px;
    grid-template-columns: repeat(3, 58px);
    grid-template-rows: repeat(2, 58px);
    justify-content: center;
  }
  .mobile-controls button {
    width: 58px; height: 58px; font-size: 1.4rem; border: none; border-radius: 12px;
    background: #2a2a4a; color: #ddd; cursor: pointer;
    touch-action: manipulation; -webkit-appearance: none; appearance: none;
    margin: 2px;
  }
  .mobile-controls button:active { background: #3a3a6a; }
  .mobile-controls .up { grid-column: 2; grid-row: 1; }
  .mobile-controls .left { grid-column: 1; grid-row: 2; }
  .mobile-controls .down { grid-column: 2; grid-row: 2; }
  .mobile-controls .right { grid-column: 3; grid-row: 2; }

  /* Joystick */
  #joystickContainer {
    display: none; margin-top: 12px; position: relative;
    width: 150px; height: 150px; touch-action: none;
  }
  #joystickBase {
    width: 150px; height: 150px; border-radius: 50%;
    background: radial-gradient(circle, #2a2a4a 60%, #1e1e3a 100%);
    border: 2px solid #3a3a5c; position: relative;
    touch-action: none;
  }
  #joystickKnob {
    width: 60px; height: 60px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #d4789c, #a04060);
    border: 2px solid rgba(255,255,255,0.15);
    position: absolute; left: 45px; top: 45px;
    box-shadow: 0 0 15px rgba(212,120,156,0.3);
    pointer-events: none;
    will-change: left, top;
  }

  @media (max-width: 600px) {
    h1 { font-size: 1.4rem; }
    .score-bar { font-size: 0.85rem; }
    .score-bar span { margin: 0 8px; }
    .overlay h2 { font-size: 1.8rem; }
    .overlay p { font-size: 0.95rem; }
  }
</style>
</head>
<body>
<h1>ğŸ† Snaked</h1>
<div class="score-bar">
  <span>Score: <strong id="score">0</strong></span>
  <span>Niveau: <strong id="level">1</strong></span>
  <span>Record: <strong id="highscore">0</strong></span>
</div>
<div class="game-wrap">
  <canvas id="game" width="600" height="600"></canvas>
  <div class="overlay" id="startScreen">
    <h2>ğŸ† Snaked</h2>
    <p>Mange les ğŸ‘ pour grandir !</p>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:8px;">Choisis tes contrÃ´les :</p>
    <div class="control-choice" id="controlChoiceStart">
      <button id="choiceArrows" data-mode="arrows">
        <span class="icon">âŒ¨ï¸</span>
        FlÃ¨ches
      </button>
      <button id="choiceJoystick" data-mode="joystick">
        <span class="icon">ğŸ•¹ï¸</span>
        Joystick
      </button>
    </div>
    <button class="play-btn" id="btnStart">Jouer</button>
  </div>
  <div class="overlay" id="gameOverScreen" style="display:none;">
    <h2>ğŸ’€ Game Over</h2>
    <p>Score: <strong id="finalScore">0</strong> â€” Niveau <strong id="finalLevel">1</strong></p>
    <p style="font-size:0.9rem;color:#999;" id="obsCount"></p>
    <p style="font-size:0.9rem;color:#aaa;margin-bottom:8px;">ContrÃ´les :</p>
    <div class="control-choice" id="controlChoiceRestart">
      <button id="choiceArrows2" data-mode="arrows">
        <span class="icon">âŒ¨ï¸</span>
        FlÃ¨ches
      </button>
      <button id="choiceJoystick2" data-mode="joystick">
        <span class="icon">ğŸ•¹ï¸</span>
        Joystick
      </button>
    </div>
    <button class="play-btn" id="btnRestart">Rejouer</button>
  </div>
</div>
<div class="controls" id="controlsHint">FlÃ¨ches / ZQSD pour diriger</div>
<div class="mobile-controls" id="arrowControls">
  <button class="up" data-dir="0,-1">â–²</button>
  <button class="left" data-dir="-1,0">â—€</button>
  <button class="down" data-dir="0,1">â–¼</button>
  <button class="right" data-dir="1,0">â–¶</button>
</div>
<div id="joystickContainer">
  <div id="joystickBase">
    <div id="joystickKnob"></div>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INIT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var canvas = document.getElementById('game');
var ctx = canvas.getContext('2d');
var GRID = 24;
var COLS = canvas.width / GRID;
var ROWS = canvas.height / GRID;

var snake, dir, nextDir, food, score, highScore = 0, gameLoop = null, speed;
var smoothSnake = [];
var lastTime = 0, moveTimer = 0;
var obstacles = [];
var bonusFood = null;
var gameRunning = false;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PREVENT SCROLLING / BOUNCING (targeted â€” not global)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
canvas.addEventListener('touchstart', function(e) { e.preventDefault(); }, { passive: false });

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EMOJI PRE-RENDERS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function preRenderEmoji(emoji, size) {
  size = size || 40;
  var c = document.createElement('canvas');
  c.width = size; c.height = size;
  var cx = c.getContext('2d');
  cx.font = (size - 6) + 'px serif';
  cx.textAlign = 'center';
  cx.textBaseline = 'middle';
  cx.fillText(emoji, size/2, size/2 + 2);
  return c;
}
var peachCanvas = preRenderEmoji('ğŸ‘');
var goldenPeachCanvas = preRenderEmoji('ğŸ‘');
var skullCanvas = preRenderEmoji('ğŸ’€');

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOUND â€” iOS/Android/Desktop compatible
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var audioCtx = null;
var audioUnlocked = false;
var sounds = {};

function initAudioContext() {
  if (audioCtx) return;
  try {
    var AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
  } catch(e) {}
}

function unlockAudio() {
  if (audioUnlocked) return;
  initAudioContext();
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(function(){});
  }
  var allSounds = [sounds.eat, sounds.death, sounds.bonus];
  for (var i = 0; i < allSounds.length; i++) {
    if (allSounds[i]) {
      allSounds[i].volume = 0.01;
      var p = allSounds[i].play();
      if (p && p.then) {
        (function(s) {
          p.then(function() { s.pause(); s.currentTime = 0; s.volume = s._vol || 0.7; }).catch(function(){});
        })(allSounds[i]);
      }
    }
  }
  audioUnlocked = true;
}

function loadSound(url, vol) {
  var audio = new Audio();
  audio.preload = 'auto';
  audio._vol = vol;
  audio.volume = vol;
  audio.src = url;
  audio.load();
  return audio;
}

function playSound(s) {
  if (!s) return;
  try {
    s.currentTime = 0;
    s.volume = s._vol || 0.7;
    var p = s.play();
    if (p && p.catch) p.catch(function(){});
  } catch(e) {}
}

sounds.eat = loadSound('https://cdn.freesound.org/previews/251/251706_1730960-lq.mp3', 0.7);
sounds.death = loadSound('https://cdn.freesound.org/previews/751/751340_71257-lq.mp3', 0.8);
sounds.bonus = loadSound('https://cdn.freesound.org/previews/403/403828_7821460-lq.mp3', 0.85);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EJACULATION PARTICLE SYSTEM
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var particles = [];

function spawnEjaculation() {
  var h = smoothSnake[0];
  var dx = dir.x, dy = dir.y;
  var i, spread, spd, sp;

  for (i = 0; i < 28; i++) {
    spread = (Math.random() - 0.5) * 1.6;
    spd = 3 + Math.random() * 6;
    particles.push({
      x: h.x + dx * GRID * 0.5, y: h.y + dy * GRID * 0.5,
      vx: dx * spd + (-dy) * spread * spd * 0.35,
      vy: dy * spd + dx * spread * spd * 0.35,
      size: 2.5 + Math.random() * 5,
      life: 1, decay: 0.007 + Math.random() * 0.014,
      gravity: 0.04 + Math.random() * 0.04,
      type: 'drop',
      wobble: Math.random() * 6.28, wobbleSpd: 0.06 + Math.random() * 0.08
    });
  }
  for (i = 0; i < 5; i++) {
    sp = (Math.random() - 0.5) * 0.6;
    spd = 2.5 + Math.random() * 2.5;
    particles.push({
      x: h.x + dx * GRID * 0.4, y: h.y + dy * GRID * 0.4,
      vx: dx * spd + (-dy) * sp * spd * 0.25,
      vy: dy * spd + dx * sp * spd * 0.25,
      size: 2, life: 1, decay: 0.005 + Math.random() * 0.007,
      gravity: 0.05, type: 'string',
      trail: [], wobble: 0, wobbleSpd: 0
    });
  }
}

function updateParticles() {
  for (var i = particles.length - 1; i >= 0; i--) {
    var p = particles[i];
    p.life -= p.decay;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    if (p.type === 'string') { p.trail.push({x:p.x,y:p.y}); if (p.trail.length > 14) p.trail.shift(); }
    p.vx *= 0.984; p.vy *= 0.984;
    p.vy += p.gravity;
    if (p.wobble !== undefined) p.wobble += p.wobbleSpd;
    p.x += p.vx + (p.wobble ? Math.sin(p.wobble) * 0.3 : 0);
    p.y += p.vy;
    p.size *= 0.998;
  }
}

function drawParticles() {
  for (var pi = 0; pi < particles.length; pi++) {
    var p = particles[pi];
    var a = Math.min(1, p.life * 1.5);

    if (p.type === 'string' && p.trail.length > 2) {
      ctx.strokeStyle = 'rgba(248,244,238,' + (a*0.55) + ')';
      ctx.lineWidth = 1.8 * p.life; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.beginPath(); ctx.moveTo(p.trail[0].x, p.trail[0].y);
      for (var t = 1; t < p.trail.length; t++) ctx.lineTo(p.trail[t].x, p.trail[t].y);
      ctx.lineTo(p.x, p.y); ctx.stroke();
      ctx.fillStyle = 'rgba(252,248,242,' + (a*0.8) + ')';
      ctx.beginPath(); ctx.arc(p.x, p.y, 2.5*p.life, 0, Math.PI*2); ctx.fill();
    } else {
      var spd2 = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
      var ang = Math.atan2(p.vy, p.vx);
      ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(ang);
      var stretch = 1 + spd2 * 0.12;

      var gl = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size * 2.5);
      gl.addColorStop(0, 'rgba(255,255,255,' + (a*0.15) + ')');
      gl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gl;
      ctx.beginPath(); ctx.ellipse(0, 0, p.size*2.5*stretch, p.size*2.5, 0, 0, Math.PI*2); ctx.fill();

      var gr = ctx.createRadialGradient(-p.size*0.15, -p.size*0.15, 0, 0, 0, p.size);
      gr.addColorStop(0, 'rgba(255,252,248,' + (a*0.95) + ')');
      gr.addColorStop(0.4, 'rgba(245,240,232,' + (a*0.8) + ')');
      gr.addColorStop(0.75, 'rgba(232,226,218,' + (a*0.45) + ')');
      gr.addColorStop(1, 'rgba(220,216,208,0)');
      ctx.fillStyle = gr;
      ctx.beginPath(); ctx.ellipse(0, 0, p.size*stretch, p.size, 0, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,' + (a*0.55) + ')';
      ctx.beginPath(); ctx.arc(-p.size*0.22, -p.size*0.22, p.size*0.28, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONTROLS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var controlMode = 'arrows';

function selectControl(mode) {
  controlMode = mode;
  document.getElementById('choiceArrows').classList.toggle('selected', mode === 'arrows');
  document.getElementById('choiceJoystick').classList.toggle('selected', mode === 'joystick');
  var a2 = document.getElementById('choiceArrows2');
  var j2 = document.getElementById('choiceJoystick2');
  if (a2) a2.classList.toggle('selected', mode === 'arrows');
  if (j2) j2.classList.toggle('selected', mode === 'joystick');
}
selectControl('arrows');

function setDir(x, y) {
  if (!gameRunning) return;
  if (x !== -dir.x || y !== -dir.y) nextDir = {x:x, y:y};
}

// Keyboard â€” always works
document.addEventListener('keydown', function(e) {
  var m = {
    ArrowUp:[0,-1], ArrowDown:[0,1], ArrowLeft:[-1,0], ArrowRight:[1,0],
    z:[0,-1], s:[0,1], q:[-1,0], d:[1,0],
    Z:[0,-1], S:[0,1], Q:[-1,0], D:[1,0]
  };
  if (m[e.key]) { e.preventDefault(); setDir(m[e.key][0], m[e.key][1]); }
});

/* â”€â”€ Arrow buttons â€” touchstart primary, pointer/mouse fallback â”€â”€ */
(function initArrowButtons() {
  var btns = document.querySelectorAll('#arrowControls button[data-dir]');
  for (var i = 0; i < btns.length; i++) {
    (function(btn) {
      var parts = btn.getAttribute('data-dir').split(',');
      var x = parseInt(parts[0], 10);
      var y = parseInt(parts[1], 10);
      var handled = false;

      btn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        handled = true;
        setDir(x, y);
        setTimeout(function() { handled = false; }, 300);
      }, { passive: false });

      btn.addEventListener('click', function(e) {
        e.preventDefault();
        if (!handled) setDir(x, y);
      });
    })(btns[i]);
  }
})();

/* â”€â”€ Joystick â€” touch primary, mouse fallback â”€â”€ */
(function initJoystick() {
  var base = document.getElementById('joystickBase');
  var knob = document.getElementById('joystickKnob');
  if (!base || !knob) return;

  var deadZone = 18;
  var active = false;

  function moveKnob(clientX, clientY) {
    var rect = base.getBoundingClientRect();
    var centerX = rect.left + rect.width / 2;
    var centerY = rect.top + rect.height / 2;
    var ox = clientX - centerX;
    var oy = clientY - centerY;
    var dist = Math.sqrt(ox*ox + oy*oy);
    var maxDist = rect.width / 2 - 30; // 30 = knob radius

    var kx = ox, ky = oy;
    if (dist > maxDist) {
      kx = ox / dist * maxDist;
      ky = oy / dist * maxDist;
    }

    // Position knob (left/top relative to base, account for knob size 60px)
    knob.style.left = (rect.width/2 + kx - 30) + 'px';
    knob.style.top = (rect.height/2 + ky - 30) + 'px';

    if (dist > deadZone) {
      var angle = Math.atan2(oy, ox);
      if (angle > -Math.PI/4 && angle <= Math.PI/4) setDir(1, 0);
      else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) setDir(0, 1);
      else if (angle > -3*Math.PI/4 && angle <= -Math.PI/4) setDir(0, -1);
      else setDir(-1, 0);
    }
  }

  function resetKnob() {
    active = false;
    knob.style.left = '45px';
    knob.style.top = '45px';
    knob.style.boxShadow = '0 0 15px rgba(212,120,156,0.3)';
  }

  // Touch events â€” most reliable on iOS Safari
  base.addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    active = true;
    knob.style.boxShadow = '0 0 25px rgba(212,120,156,0.6)';
    moveKnob(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });

  base.addEventListener('touchmove', function(e) {
    if (!active) return;
    e.preventDefault();
    e.stopPropagation();
    moveKnob(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });

  base.addEventListener('touchend', function(e) {
    e.preventDefault();
    if (active) resetKnob();
  }, { passive: false });

  base.addEventListener('touchcancel', function() {
    if (active) resetKnob();
  });

  // Mouse fallback for desktop
  var mouseDown = false;
  base.addEventListener('mousedown', function(e) {
    e.preventDefault();
    mouseDown = true;
    active = true;
    knob.style.boxShadow = '0 0 25px rgba(212,120,156,0.6)';
    moveKnob(e.clientX, e.clientY);
  });
  document.addEventListener('mousemove', function(e) {
    if (!mouseDown) return;
    moveKnob(e.clientX, e.clientY);
  });
  document.addEventListener('mouseup', function() {
    if (mouseDown) { mouseDown = false; resetKnob(); }
  });
})();

function showControls() {
  var arrows = document.getElementById('arrowControls');
  var joystick = document.getElementById('joystickContainer');
  var hint = document.getElementById('controlsHint');
  if (controlMode === 'joystick') {
    arrows.style.display = 'none';
    joystick.style.display = 'block';
    hint.textContent = 'Joystick pour diriger';
  } else {
    joystick.style.display = 'none';
    arrows.style.display = 'grid';
    hint.textContent = 'FlÃ¨ches / ZQSD pour diriger';
  }
}

/* â”€â”€ Overlay buttons â€” simple click (viewport meta eliminates 300ms delay on iOS) â”€â”€ */
(function initButtons() {
  document.getElementById('btnStart').addEventListener('click', function(e) {
    e.preventDefault(); startGame();
  });
  document.getElementById('btnRestart').addEventListener('click', function(e) {
    e.preventDefault(); startGame();
  });

  var choiceBtns = document.querySelectorAll('.control-choice button[data-mode]');
  for (var i = 0; i < choiceBtns.length; i++) {
    (function(btn) {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        selectControl(btn.getAttribute('data-mode'));
      });
    })(choiceBtns[i]);
  }
})();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME LOGIC
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function isCellOccupied(x, y) {
  var i;
  for (i = 0; i < snake.length; i++) { if (snake[i].x===x && snake[i].y===y) return true; }
  if (food && food.x===x && food.y===y) return true;
  if (bonusFood && bonusFood.x===x && bonusFood.y===y) return true;
  for (i = 0; i < obstacles.length; i++) { if (obstacles[i].x===x && obstacles[i].y===y) return true; }
  return false;
}

function spawnFood() {
  var p;
  do { p = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)}; }
  while (isCellOccupied(p.x, p.y));
  food = p;
  if (!bonusFood && Math.random() < 0.25) {
    var bp;
    do { bp = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)}; }
    while (isCellOccupied(bp.x, bp.y));
    bonusFood = bp;
  }
}

var screenFlash = 0;
var currentLevel = 1;
var levelUpText = { active: false, time: 0, level: 0 };

function getSkullCount(lvl) {
  // Lvl 1: 0, Lvl 2: 2, Lvl 3: 4, Lvl 4: 6, Lvl 5+: 8 (capped)
  if (lvl <= 1) return 0;
  return Math.min((lvl - 1) * 2, 8);
}

function spawnSafePos() {
  var p, attempts = 0;
  do {
    p = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    attempts++;
  } while (isCellOccupied(p.x, p.y) && attempts < 150);
  if (attempts >= 150) return null;
  var hd = snake[0];
  if (Math.abs(p.x-hd.x) + Math.abs(p.y-hd.y) < 4) return null;
  return p;
}

function spawnLevelObstacles(lvl) {
  var target = getSkullCount(lvl);
  if (target === 0) return;
  var now = performance.now();
  var i, p;

  if (lvl > 5) {
    // After level 5: clear all and regenerate at same count (fresh positions)
    obstacles = [];
  }

  // Spawn skulls up to target
  var toSpawn = target - obstacles.length;
  for (i = 0; i < toSpawn; i++) {
    p = spawnSafePos();
    if (p) obstacles.push({ x:p.x, y:p.y, type:'skull', spawnTime: now, level: lvl });
  }
  screenFlash = 1;
}

function startGame() {
  unlockAudio();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  showControls();
  var cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
  snake = [];
  for (var i = 0; i < 5; i++) snake.push({x:cx-i, y:cy});
  smoothSnake = [];
  for (var j = 0; j < snake.length; j++) {
    smoothSnake.push({x:snake[j].x*GRID+GRID/2, y:snake[j].y*GRID+GRID/2});
  }
  dir = {x:1, y:0}; nextDir = {x:1, y:0};
  score = 0; speed = 120; particles = []; obstacles = []; screenFlash = 0; bonusFood = null;
  currentLevel = 1; levelUpText = { active: false, time: 0, level: 0 };
  gameRunning = true;
  document.getElementById('score').textContent = '0';
  document.getElementById('level').textContent = '1';
  spawnFood();
  if (gameLoop) cancelAnimationFrame(gameLoop);
  lastTime = performance.now(); moveTimer = 0;
  loop(lastTime);
}

function gameOver() {
  gameRunning = false;
  cancelAnimationFrame(gameLoop); gameLoop = null;
  playSound(sounds.death);
  if (score > highScore) { highScore = score; document.getElementById('highscore').textContent = highScore; }
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalLevel').textContent = Math.floor(score/5) + 1;
  document.getElementById('obsCount').textContent = obstacles.length > 0 ? obstacles.length + ' \uD83D\uDC80 sur le terrain' : '';
  document.getElementById('gameOverScreen').style.display = 'flex';
  selectControl(controlMode); // sync buttons visual state
}

function logic() {
  dir = nextDir;
  var head = {x:snake[0].x+dir.x, y:snake[0].y+dir.y};
  // Wrap around edges
  if (head.x < 0) head.x = COLS - 1;
  else if (head.x >= COLS) head.x = 0;
  if (head.y < 0) head.y = ROWS - 1;
  else if (head.y >= ROWS) head.y = 0;
  var i;
  for (i = 0; i < snake.length; i++) {
    if (snake[i].x===head.x && snake[i].y===head.y) return gameOver();
  }
  for (i = 0; i < obstacles.length; i++) {
    if (obstacles[i].x===head.x && obstacles[i].y===head.y) return gameOver();
  }

  snake.unshift(head);
  smoothSnake.unshift({x:snake[1].x*GRID+GRID/2, y:snake[1].y*GRID+GRID/2});

  var ate = false;
  if (head.x===food.x && head.y===food.y) {
    score++; playSound(sounds.eat); spawnEjaculation(); spawnFood(); ate = true;
  } else if (bonusFood && head.x===bonusFood.x && head.y===bonusFood.y) {
    score += 2; playSound(sounds.bonus); spawnEjaculation(); bonusFood = null; ate = true;
  }

  if (ate) {
    document.getElementById('score').textContent = score;
    if (speed > 55) speed -= 1.5;
    var newLvl = Math.floor(score / 5) + 1;
    if (newLvl > currentLevel) {
      currentLevel = newLvl;
      document.getElementById('level').textContent = currentLevel;
      spawnLevelObstacles(currentLevel);
      levelUpText = { active: true, time: performance.now(), level: currentLevel };
    }
  } else {
    snake.pop(); smoothSnake.pop();
  }
}

function loop(now) {
  gameLoop = requestAnimationFrame(loop);
  var dt = now - lastTime; lastTime = now; moveTimer += dt;
  if (moveTimer >= speed) { moveTimer -= speed; logic(); }
  for (var i = 0; i < snake.length; i++) {
    var t = {x:snake[i].x*GRID+GRID/2, y:snake[i].y*GRID+GRID/2};
    var ddx = t.x - smoothSnake[i].x;
    var ddy = t.y - smoothSnake[i].y;
    // Snap if wrap-around (distance > half canvas)
    if (Math.abs(ddx) > canvas.width * 0.4 || Math.abs(ddy) > canvas.height * 0.4) {
      smoothSnake[i].x = t.x;
      smoothSnake[i].y = t.y;
    } else {
      smoothSnake[i].x += ddx * 0.28;
      smoothSnake[i].y += ddy * 0.28;
    }
  }
  updateParticles();
  draw();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CATMULL-ROM SPLINE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getSpine(pts, sub) {
  sub = sub || 5;
  if (pts.length < 2) return pts.slice();
  var sp = [];
  for (var i = 0; i < pts.length-1; i++) {
    var p0 = pts[Math.max(i-1,0)];
    var p1 = pts[i];
    var p2 = pts[Math.min(i+1,pts.length-1)];
    var p3 = pts[Math.min(i+2,pts.length-1)];
    for (var j = 0; j < sub; j++) {
      var t = j/sub, tt = t*t, ttt = tt*t;
      sp.push({
        x: 0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*tt+(-p0.x+3*p1.x-3*p2.x+p3.x)*ttt),
        y: 0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*tt+(-p0.y+3*p1.y-3*p2.y+p3.y)*ttt)
      });
    }
  }
  sp.push(pts[pts.length-1]);
  return sp;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DRAW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Split smoothSnake into continuous segments (break at wrap points)
function getSegments(pts) {
  var segs = [];
  var cur = [pts[0]];
  var curStart = 0;
  for (var i = 1; i < pts.length; i++) {
    var ddx = pts[i].x - pts[i-1].x;
    var ddy = pts[i].y - pts[i-1].y;
    if (Math.abs(ddx) > canvas.width * 0.35 || Math.abs(ddy) > canvas.height * 0.35) {
      // Wrap detected â€” close current segment, start new one
      if (cur.length >= 2) segs.push({ pts: cur, startIdx: curStart });
      cur = [pts[i]];
      curStart = i;
    } else {
      cur.push(pts[i]);
    }
  }
  if (cur.length >= 2) segs.push({ pts: cur, startIdx: curStart });
  return segs;
}

function drawBodySegment(seg, totalLen, isHead, isTail) {
  var spine = getSpine(seg.pts, 5);
  var sLen = spine.length;
  if (sLen < 2) return;

  var globalTotal = Math.max(1, (totalLen - 1) * 5 + 1); // approximate total spine length
  var segGlobalStart = seg.startIdx;
  var segSmoothLen = seg.pts.length;
  var i, w, dx, dy, m, st;

  // Normals
  var normals = [];
  for (i = 0; i < sLen; i++) {
    if (i === 0) { dx = spine[1].x - spine[0].x; dy = spine[1].y - spine[0].y; }
    else if (i === sLen-1) { dx = spine[sLen-1].x - spine[sLen-2].x; dy = spine[sLen-1].y - spine[sLen-2].y; }
    else { dx = spine[i+1].x - spine[i-1].x; dy = spine[i+1].y - spine[i-1].y; }
    m = Math.sqrt(dx*dx + dy*dy) || 1;
    normals.push({x: -dy/m, y: dx/m});
  }

  // Width profile â€” maps local spine index to global snake position
  function getW(idx) {
    // Map local idx to global fraction
    var localFrac = idx / (sLen - 1);
    var globalSmooth = segGlobalStart + localFrac * (segSmoothLen - 1);
    var t2 = globalSmooth / (totalLen - 1);
    var base = GRID * 0.5;
    if (t2 < 0.015) return base * 0.6;
    if (t2 < 0.05) return base * 1.0;
    if (t2 < 0.09) return base * 1.15;
    if (t2 < 0.12) return base * 1.22;
    if (t2 < 0.15) return base * 0.82;
    if (t2 > 0.93) return base * Math.max(0.1, 0.8 - (t2 - 0.93) * 10);
    return base * (0.9 + 0.07 * Math.sin(t2 * 14));
  }

  var leftPts = [], rightPts = [];
  for (i = 0; i < sLen; i++) {
    w = getW(i);
    leftPts.push({x: spine[i].x + normals[i].x * w, y: spine[i].y + normals[i].y * w});
    rightPts.push({x: spine[i].x - normals[i].x * w, y: spine[i].y - normals[i].y * w});
  }

  // Shadow
  ctx.save(); ctx.translate(3, 5);
  ctx.beginPath(); ctx.moveTo(leftPts[0].x, leftPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(leftPts[i].x, leftPts[i].y);
  for (i = sLen-1; i >= 0; i--) ctx.lineTo(rightPts[i].x, rightPts[i].y);
  ctx.closePath(); ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fill(); ctx.restore();

  // Main body (clipped)
  ctx.save();
  ctx.beginPath(); ctx.moveTo(leftPts[0].x, leftPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(leftPts[i].x, leftPts[i].y);
  for (i = sLen-1; i >= 0; i--) ctx.lineTo(rightPts[i].x, rightPts[i].y);
  ctx.closePath(); ctx.clip();

  // Skin gradient
  var hP = spine[0], tP2 = spine[sLen-1];
  var bg = ctx.createLinearGradient(hP.x, hP.y, tP2.x, tP2.y);
  bg.addColorStop(0, '#d48da5'); bg.addColorStop(0.10, '#c87a94');
  bg.addColorStop(0.17, '#dbb5a0'); bg.addColorStop(0.3, '#d4a88c');
  bg.addColorStop(0.7, '#cfa085'); bg.addColorStop(1, '#c89878');
  ctx.fillStyle = bg; ctx.fillRect(0, 0, canvas.width, canvas.height);

  // 3D cylinder shading
  for (i = 0; i < sLen-1; i++) {
    w = getW(i);
    var cx2 = spine[i].x, cy2 = spine[i].y, nx2 = normals[i].x, ny2 = normals[i].y;
    var g = ctx.createLinearGradient(cx2+nx2*w, cy2+ny2*w, cx2-nx2*w, cy2-ny2*w);
    g.addColorStop(0, 'rgba(255,230,220,0.35)'); g.addColorStop(0.2, 'rgba(255,255,255,0.12)');
    g.addColorStop(0.45, 'rgba(0,0,0,0)'); g.addColorStop(0.7, 'rgba(0,0,0,0.08)');
    g.addColorStop(1, 'rgba(0,0,0,0.22)');
    ctx.fillStyle = g; ctx.beginPath();
    ctx.moveTo(leftPts[i].x, leftPts[i].y); ctx.lineTo(leftPts[i+1].x, leftPts[i+1].y);
    ctx.lineTo(rightPts[i+1].x, rightPts[i+1].y); ctx.lineTo(rightPts[i].x, rightPts[i].y);
    ctx.closePath(); ctx.fill();
  }

  // Dorsal vein
  st = false;
  ctx.strokeStyle = 'rgba(140,85,95,0.18)'; ctx.lineWidth = 2; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.beginPath();
  for (i = Math.floor(sLen*0.15); i < Math.floor(sLen*0.88); i += 2) {
    var o = 0.28 + Math.sin(i*0.08) * 0.08;
    var vx = spine[i].x + normals[i].x * getW(i) * o + Math.sin(i*0.12) * 2.5;
    var vy = spine[i].y + normals[i].y * getW(i) * o + Math.cos(i*0.1) * 2.5;
    if (!st) { ctx.moveTo(vx, vy); st = true; } else ctx.lineTo(vx, vy);
  }
  ctx.stroke();

  // Secondary veins
  for (var v = 0; v < 3; v++) {
    ctx.strokeStyle = 'rgba(150,100,110,' + (0.06+v*0.02) + ')'; ctx.lineWidth = 0.8;
    ctx.beginPath(); st = false;
    var ov = [-0.35, 0.1, -0.15][v];
    var s0 = Math.floor(sLen*(0.18+v*0.08)), s1 = Math.floor(sLen*(0.65+v*0.1));
    for (i = s0; i < s1; i += 3) {
      var vx2 = spine[i].x + normals[i].x * getW(i) * ov + Math.sin(i*0.2+v*5) * 1.5;
      var vy2 = spine[i].y + normals[i].y * getW(i) * ov + Math.cos(i*0.15+v*5) * 1.5;
      if (!st) { ctx.moveTo(vx2, vy2); st = true; } else ctx.lineTo(vx2, vy2);
    }
    ctx.stroke();
  }

  // Top specular
  ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 3.5;
  ctx.beginPath(); st = false;
  for (i = Math.floor(sLen*0.04); i < Math.floor(sLen*0.92); i += 2) {
    var hx = spine[i].x + normals[i].x * getW(i) * 0.6;
    var hy = spine[i].y + normals[i].y * getW(i) * 0.6;
    if (!st) { ctx.moveTo(hx, hy); st = true; } else ctx.lineTo(hx, hy);
  }
  ctx.stroke();

  // Skin pores
  ctx.fillStyle = 'rgba(180,130,110,0.04)';
  for (i = Math.floor(sLen*0.15); i < Math.floor(sLen*0.9); i += 4) {
    for (var d2 = 0; d2 < 2; d2++) {
      var px = spine[i].x + normals[i].x * getW(i) * (Math.sin(i+d2*11)*0.5) + Math.sin(i*2.3+d2*7) * 2;
      var py = spine[i].y + normals[i].y * getW(i) * (Math.cos(i+d2*7)*0.5) + Math.cos(i*1.8+d2*3) * 2;
      ctx.beginPath(); ctx.arc(px, py, 0.8, 0, Math.PI*2); ctx.fill();
    }
  }
  ctx.restore();

  // Outline
  ctx.strokeStyle = 'rgba(110,65,55,0.12)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(leftPts[0].x, leftPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(leftPts[i].x, leftPts[i].y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(rightPts[0].x, rightPts[0].y);
  for (i = 1; i < sLen; i++) ctx.lineTo(rightPts[i].x, rightPts[i].y); ctx.stroke();

  // â”€â”€ HEAD FEATURES (only for head segment) â”€â”€
  if (isHead) {
    var cIdx = Math.floor(sLen * 0.13);
    if (cIdx < sLen) {
      ctx.strokeStyle = 'rgba(175,95,115,0.45)'; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(leftPts[cIdx].x, leftPts[cIdx].y); ctx.lineTo(rightPts[cIdx].x, rightPts[cIdx].y); ctx.stroke();
      ctx.strokeStyle = 'rgba(225,175,185,0.3)'; ctx.lineWidth = 1.2;
      var c2 = Math.max(cIdx-2, 0);
      ctx.beginPath(); ctx.moveTo(leftPts[c2].x, leftPts[c2].y); ctx.lineTo(rightPts[c2].x, rightPts[c2].y); ctx.stroke();
    }
    // Meatus
    var tN = Math.min(3, sLen-1);
    var tDx = spine[tN].x - spine[0].x, tDy = spine[tN].y - spine[0].y;
    var tMag = Math.sqrt(tDx*tDx + tDy*tDy) || 1;
    var tNx = -tDy/tMag, tNy = tDx/tMag, mL = GRID * 0.22;
    ctx.strokeStyle = 'rgba(115,40,55,0.75)'; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(spine[0].x+tNx*mL, spine[0].y+tNy*mL); ctx.lineTo(spine[0].x-tNx*mL, spine[0].y-tNy*mL); ctx.stroke();
    ctx.strokeStyle = 'rgba(90,35,45,0.2)'; ctx.lineWidth = 4.5;
    ctx.beginPath(); ctx.moveTo(spine[0].x+tNx*mL*0.5, spine[0].y+tNy*mL*0.5); ctx.lineTo(spine[0].x-tNx*mL*0.5, spine[0].y-tNy*mL*0.5); ctx.stroke();
  }

  // â”€â”€ TESTICLES (only for tail segment) â”€â”€
  if (isTail && sLen > 10) {
    var tailIdx = sLen - 1;
    var tPt = spine[tailIdx];
    var prT = spine[Math.max(tailIdx - 12, 0)];
    var tdx2 = tPt.x - prT.x, tdy2 = tPt.y - prT.y;
    var tm = Math.sqrt(tdx2*tdx2 + tdy2*tdy2) || 1;
    var dirX = tdx2/tm, dirY = tdy2/tm;
    var tnx = -dirY, tny = dirX;

    var bR = GRID * 0.77;
    var spread2 = bR * 0.72;
    var drop2 = bR * 0.05;

    var b1 = { x: tPt.x + dirX*drop2 + tnx*spread2, y: tPt.y + dirY*drop2 + tny*spread2 };
    var b2 = { x: tPt.x + dirX*drop2 - tnx*spread2, y: tPt.y + dirY*drop2 - tny*spread2 };
    var bAng = Math.atan2(dirY, dirX) + Math.PI/2;
    var blendIdx = Math.max(0, Math.floor(sLen * 0.82));

    var balls = [b1, b2];
    for (var bi = 0; bi < 2; bi++) {
      var ball = balls[bi];
      var side = bi === 0 ? 1 : -1;
      ctx.fillStyle = 'rgba(30,15,10,0.25)';
      ctx.beginPath(); ctx.ellipse(ball.x+3, ball.y+4, bR*0.92, bR*1.02, bAng, 0, Math.PI*2); ctx.fill();
      var mg = ctx.createRadialGradient(ball.x-tnx*side*bR*0.25-dirX*bR*0.25, ball.y-tny*side*bR*0.25-dirY*bR*0.25, bR*0.05, ball.x, ball.y, bR);
      mg.addColorStop(0,'#ecd5be'); mg.addColorStop(0.25,'#dfc4a8'); mg.addColorStop(0.5,'#d0ae90'); mg.addColorStop(0.75,'#bf9a7c'); mg.addColorStop(1,'#a88468');
      ctx.fillStyle=mg; ctx.beginPath(); ctx.ellipse(ball.x, ball.y, bR*0.88, bR, bAng, 0, Math.PI*2); ctx.fill();
      var hl = ctx.createRadialGradient(ball.x-tnx*side*bR*0.2-dirX*bR*0.3, ball.y-tny*side*bR*0.2-dirY*bR*0.3, bR*0.02, ball.x-tnx*side*bR*0.1-dirX*bR*0.15, ball.y-tny*side*bR*0.1-dirY*bR*0.15, bR*0.7);
      hl.addColorStop(0,'rgba(255,250,240,0.5)'); hl.addColorStop(0.3,'rgba(255,240,225,0.28)'); hl.addColorStop(0.7,'rgba(255,230,210,0.08)'); hl.addColorStop(1,'rgba(255,220,200,0)');
      ctx.fillStyle=hl; ctx.beginPath(); ctx.ellipse(ball.x, ball.y, bR*0.88, bR, bAng, 0, Math.PI*2); ctx.fill();
      var bs = ctx.createRadialGradient(ball.x+dirX*bR*0.5, ball.y+dirY*bR*0.5, bR*0.1, ball.x+dirX*bR*0.3, ball.y+dirY*bR*0.3, bR);
      bs.addColorStop(0,'rgba(70,40,25,0.3)'); bs.addColorStop(0.5,'rgba(70,40,25,0.1)'); bs.addColorStop(1,'rgba(70,40,25,0)');
      ctx.fillStyle=bs; ctx.beginPath(); ctx.ellipse(ball.x+dirX*bR*0.15, ball.y+dirY*bR*0.15, bR*0.85, bR*0.95, bAng, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.35)'; ctx.beginPath();
      ctx.ellipse(ball.x-tnx*side*bR*0.22-dirX*bR*0.32, ball.y-tny*side*bR*0.22-dirY*bR*0.32, bR*0.15, bR*0.1, bAng-0.4*side, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(140,95,70,0.22)'; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.ellipse(ball.x, ball.y, bR*0.88, bR, bAng, 0, Math.PI*2); ctx.stroke();
      ctx.strokeStyle='rgba(155,110,85,0.1)'; ctx.lineWidth=0.7;
      for(var ww=-2;ww<=2;ww++){
        ctx.beginPath(); ctx.arc(ball.x+dirX*ww*bR*0.07, ball.y+dirY*ww*bR*0.07, bR*0.65, bAng-0.6, bAng+0.6); ctx.stroke();
      }
    }
    // Skin bridge
    var skinGrd = ctx.createLinearGradient(tPt.x-tnx*spread2, tPt.y-tny*spread2, tPt.x+tnx*spread2, tPt.y+tny*spread2);
    skinGrd.addColorStop(0,'#c9a080'); skinGrd.addColorStop(0.5,'#d4ae8e'); skinGrd.addColorStop(1,'#c9a080');
    ctx.fillStyle=skinGrd; ctx.beginPath();
    ctx.moveTo(leftPts[blendIdx].x, leftPts[blendIdx].y);
    for(i=blendIdx;i<=tailIdx;i++) ctx.lineTo(leftPts[i].x, leftPts[i].y);
    ctx.bezierCurveTo(tPt.x+tnx*spread2*0.5-dirX*bR*0.3, tPt.y+tny*spread2*0.5-dirY*bR*0.3, b1.x-dirX*bR*0.6, b1.y-dirY*bR*0.6, b1.x-dirX*bR*0.2+tnx*bR*0.3, b1.y-dirY*bR*0.2+tny*bR*0.3);
    ctx.bezierCurveTo(tPt.x-dirX*bR*0.5+tnx*spread2*0.3, tPt.y-dirY*bR*0.5+tny*spread2*0.3, tPt.x-dirX*bR*0.5-tnx*spread2*0.3, tPt.y-dirY*bR*0.5-tny*spread2*0.3, b2.x-dirX*bR*0.2-tnx*bR*0.3, b2.y-dirY*bR*0.2-tny*bR*0.3);
    ctx.bezierCurveTo(b2.x-dirX*bR*0.6, b2.y-dirY*bR*0.6, tPt.x-tnx*spread2*0.5-dirX*bR*0.3, tPt.y-tny*spread2*0.5-dirY*bR*0.3, rightPts[tailIdx].x, rightPts[tailIdx].y);
    for(i=tailIdx;i>=blendIdx;i--) ctx.lineTo(rightPts[i].x, rightPts[i].y);
    ctx.closePath(); ctx.fill();
    // Bridge shading
    var bsh = ctx.createLinearGradient(tPt.x+tnx*spread2, tPt.y+tny*spread2, tPt.x-tnx*spread2, tPt.y-tny*spread2);
    bsh.addColorStop(0,'rgba(255,235,215,0.15)'); bsh.addColorStop(0.35,'rgba(0,0,0,0)'); bsh.addColorStop(0.65,'rgba(0,0,0,0)'); bsh.addColorStop(1,'rgba(0,0,0,0.12)');
    ctx.fillStyle=bsh; ctx.beginPath();
    ctx.moveTo(leftPts[tailIdx].x,leftPts[tailIdx].y);
    ctx.lineTo(b1.x-dirX*bR*0.3, b1.y-dirY*bR*0.3);
    ctx.lineTo(b2.x-dirX*bR*0.3, b2.y-dirY*bR*0.3);
    ctx.lineTo(rightPts[tailIdx].x,rightPts[tailIdx].y);
    ctx.closePath(); ctx.fill();
    // Raphe
    var mid = {x:(b1.x+b2.x)/2, y:(b1.y+b2.y)/2};
    ctx.strokeStyle='rgba(100,60,40,0.18)'; ctx.lineWidth=3.5; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(tPt.x, tPt.y);
    ctx.bezierCurveTo(mid.x,mid.y, mid.x+dirX*bR*0.4,mid.y+dirY*bR*0.4, mid.x+dirX*bR*0.85,mid.y+dirY*bR*0.85); ctx.stroke();
    ctx.strokeStyle='rgba(150,105,80,0.22)'; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(tPt.x-dirX*bR*0.1, tPt.y-dirY*bR*0.1);
    ctx.bezierCurveTo(mid.x-dirX*bR*0.1,mid.y-dirY*bR*0.1, mid.x+dirX*bR*0.5,mid.y+dirY*bR*0.5, mid.x+dirX*bR*0.9,mid.y+dirY*bR*0.9); ctx.stroke();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  var len = smoothSnake.length;
  if (len < 2) return;

  // Split snake into continuous segments (break at wrap points)
  var segments = getSegments(smoothSnake);

  // Draw each segment â€” tail segments first (back to front)
  for (var si = segments.length - 1; si >= 0; si--) {
    var seg = segments[si];
    var isHead = (si === 0);
    var isTail = (si === segments.length - 1);
    drawBodySegment(seg, len, isHead, isTail);
  }

  // â”€â”€ OBSTACLES (skulls only) â”€â”€
  var now = performance.now();
  for (var oi = 0; oi < obstacles.length; oi++) {
    var obs = obstacles[oi];
    var ox = obs.x * GRID + GRID/2, oy = obs.y * GRID + GRID/2;
    var fadeIn = Math.min(1, (now - obs.spawnTime) / 500);

    var intensity = Math.min(1, obs.level * 0.15);
    var pulse = 1 + Math.sin(now * 0.005 + obs.x * 0.5) * (0.08 + intensity * 0.08);
    var sG = ctx.createRadialGradient(ox, oy, 2, ox, oy, GRID*1.4*pulse);
    sG.addColorStop(0, 'rgba(200,30,200,' + ((0.25+intensity*0.15)*fadeIn) + ')');
    sG.addColorStop(0.5, 'rgba(150,10,150,' + (0.1*fadeIn) + ')'); sG.addColorStop(1, 'rgba(120,0,120,0)');
    ctx.fillStyle=sG; ctx.beginPath(); ctx.arc(ox, oy, GRID*1.4*pulse, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=fadeIn; ctx.save(); ctx.translate(ox, oy); ctx.scale(pulse, pulse);
    ctx.drawImage(skullCanvas, -20, -20, 40, 40); ctx.restore(); ctx.globalAlpha=1;

    if (now - obs.spawnTime < 600) {
      var flash = 1 - (now - obs.spawnTime) / 600;
      ctx.fillStyle = 'rgba(255,255,255,' + (flash * 0.4) + ')';
      ctx.beginPath(); ctx.arc(ox, oy, GRID * 0.8 * (1 + flash), 0, Math.PI*2); ctx.fill();
    }
  }

  // â”€â”€ PEACH FOOD â”€â”€
  var fx=food.x*GRID+GRID/2, fy=food.y*GRID+GRID/2;
  var fG=ctx.createRadialGradient(fx,fy,2,fx,fy,GRID*1.1);
  fG.addColorStop(0,'rgba(255,180,120,0.3)'); fG.addColorStop(1,'rgba(255,180,120,0)');
  ctx.fillStyle=fG; ctx.beginPath(); ctx.arc(fx,fy,GRID*1.1,0,Math.PI*2); ctx.fill();
  ctx.drawImage(peachCanvas, fx-20, fy-20, 40, 40);

  // â”€â”€ GOLDEN BONUS PEACH â”€â”€
  if (bonusFood) {
    var bx=bonusFood.x*GRID+GRID/2, by=bonusFood.y*GRID+GRID/2;
    var bpulse = 1 + Math.sin(now * 0.004) * 0.2;
    var glowR = GRID * 1.5 * bpulse;
    var bG2=ctx.createRadialGradient(bx,by,2,bx,by,glowR);
    bG2.addColorStop(0,'rgba(255,215,0,0.45)'); bG2.addColorStop(0.4,'rgba(255,200,0,0.2)'); bG2.addColorStop(1,'rgba(255,180,0,0)');
    ctx.fillStyle=bG2; ctx.beginPath(); ctx.arc(bx,by,glowR,0,Math.PI*2); ctx.fill();

    var iG=ctx.createRadialGradient(bx,by,0,bx,by,GRID*0.8);
    iG.addColorStop(0,'rgba(255,255,255,0.25)'); iG.addColorStop(1,'rgba(255,255,200,0)');
    ctx.fillStyle=iG; ctx.beginPath(); ctx.arc(bx,by,GRID*0.8,0,Math.PI*2); ctx.fill();

    ctx.save(); ctx.translate(bx, by);
    var sc = 1 + Math.sin(now * 0.005) * 0.06;
    ctx.scale(sc, sc); ctx.drawImage(goldenPeachCanvas, -20, -20, 40, 40); ctx.restore();

    for (var si = 0; si < 5; si++) {
      var sAngle = now * 0.003 + si * Math.PI * 2 / 5;
      var sDist = GRID * 0.7 + Math.sin(now * 0.006 + si * 2) * 4;
      var sx = bx + Math.cos(sAngle) * sDist, sy = by + Math.sin(sAngle) * sDist;
      var sparkAlpha = 0.5 + Math.sin(now * 0.008 + si * 1.5) * 0.4;
      var sparkSize = 2 + Math.sin(now * 0.01 + si) * 1.2;
      ctx.fillStyle = 'rgba(255,255,200,' + sparkAlpha + ')';
      ctx.beginPath(); ctx.arc(sx, sy, sparkSize, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,240,150,' + (sparkAlpha * 0.6) + ')'; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(sx-sparkSize*2, sy); ctx.lineTo(sx+sparkSize*2, sy);
      ctx.moveTo(sx, sy-sparkSize*2); ctx.lineTo(sx, sy+sparkSize*2); ctx.stroke();
    }
    ctx.font='bold 11px sans-serif'; ctx.fillStyle='rgba(255,230,100,0.9)';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('x2', bx, by-GRID*0.85);
  }

  drawParticles();

  if (screenFlash > 0) {
    ctx.fillStyle = 'rgba(255,50,50,' + (screenFlash*0.15) + ')';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    screenFlash *= 0.92;
    if (screenFlash < 0.01) screenFlash = 0;
  }

  if (levelUpText.active) {
    var elapsed = (now - levelUpText.time) / 1000;
    if (elapsed > 2.5) { levelUpText.active = false; }
    else {
      var al = elapsed < 0.3 ? elapsed / 0.3 : elapsed > 2 ? 1 - (elapsed - 2) / 0.5 : 1;
      var scl = elapsed < 0.3 ? 0.5 + elapsed / 0.3 * 0.5 : 1;
      var yy = canvas.height * 0.18 - elapsed * 8;
      ctx.save(); ctx.translate(canvas.width / 2, yy); ctx.scale(scl, scl);
      ctx.font='bold 28px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(255,200,50,' + (al*0.3) + ')';
      ctx.fillText('\u26A0 NIVEAU ' + levelUpText.level + ' \u26A0', 2, 2);
      ctx.fillStyle='rgba(255,220,80,' + al + ')';
      ctx.fillText('\u26A0 NIVEAU ' + levelUpText.level + ' \u26A0', 0, 0);
      ctx.font='14px sans-serif'; ctx.fillStyle='rgba(255,180,100,' + (al*0.8) + ')';
      ctx.fillText(obstacles.length + ' \uD83D\uDC80', 0, 30);
      ctx.restore();
    }
  }

  if (obstacles.length > 0) {
    ctx.font='11px sans-serif'; ctx.textAlign='right'; ctx.textBaseline='bottom';
    ctx.fillStyle='rgba(255,255,255,0.25)';
    ctx.fillText('\uD83D\uDC80' + obstacles.length, canvas.width - 8, canvas.height - 6);
  }
}
</script>
</body>
</html>
